<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天飞 学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://talenhao.github.io/"/>
  <updated>2020-01-01T02:58:33.000Z</updated>
  <id>https://talenhao.github.io/</id>
  
  <author>
    <name>天飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Iptables笔记</title>
    <link href="https://talenhao.github.io/2020/01/01/iptables/"/>
    <id>https://talenhao.github.io/2020/01/01/iptables/</id>
    <published>2020-01-01T02:58:33.000Z</published>
    <updated>2020-01-01T02:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><p>iptables执行链路</p><p><img src="../../../../images/iptables.png" alt="iptables"></p><h2 id="iptables-规则"><a href="#iptables-规则" class="headerlink" title="iptables 规则"></a>iptables 规则</h2><p><img src="../../../../images/iptables2.png" alt="iptables2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Iptables&quot;&gt;&lt;a href=&quot;#Iptables&quot; class=&quot;headerlink&quot; title=&quot;Iptables&quot;&gt;&lt;/a&gt;Iptables&lt;/h1&gt;&lt;p&gt;iptables执行链路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../imag
      
    
    </summary>
    
      <category term="Linux" scheme="https://talenhao.github.io/categories/Linux/"/>
    
    
      <category term="iptables" scheme="https://talenhao.github.io/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>三平面分离</title>
    <link href="https://talenhao.github.io/2019/12/27/%E4%B8%89%E5%B9%B3%E9%9D%A2%E5%88%86%E7%A6%BB/"/>
    <id>https://talenhao.github.io/2019/12/27/三平面分离/</id>
    <published>2019-12-27T06:37:33.000Z</published>
    <updated>2019-12-27T06:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据平面，控制平面，管理平面"><a href="#数据平面，控制平面，管理平面" class="headerlink" title="数据平面，控制平面，管理平面"></a><a href="https://tjlxy.lofter.com/post/335f69_99bc622" target="_blank" rel="noopener">数据平面，控制平面，管理平面</a></h2><p>转自：<a href="http://tjlxy.lofter.com/post/335f69_99bc622" target="_blank" rel="noopener">http://tjlxy.lofter.com/post/335f69_99bc622</a></p><p>管理平面/控制平面（统称控制平面）<br><strong>管理平面</strong>是提供给网络管理人员使用TELNET、WEB、SSH、SNMP、RMON 等方式来管理设备，并支持、理解和执行管理人员对于网络设备各种网络协议的设置命令。管理平面提供了控制平面正常运行的前提，管理平面必须预先设置好控制平面中各种协议的相关参数，并支持在必要时刻对控制平面的运行进行干预。</p><p><strong>控制平面</strong>用于控制和管理所有网络协议的运行，例如生成树协议、VLAN 协议、ARP协议、各种路由协议和组播协议等等的管理和控制。控制平面通过网络协议提供给路由器/交换机对整个网络环境中网络设备、连接链路和交互协议的准确了解，并在网络状况发生改变时做出及时的调整以维护网络的正常运行。控制平面提供了数据平面数据处理转发前所必须的各种网络信息和转发查询表项。控制平面并不占用过多的硬件资源，但在正常状况下依然是网络设备CPU资源的主要占用平面，因此除了优化网络设备对于控制平面的调度流程和效率，一般还可以通过提供多CPU或提高CPU的处理性能来提高网络设备的控制平面性能。<br>控制平面主要靠CPU资源来处理信息。<br>show ip route 查看IP路由表，属控制平面范畴（路由信息数据库，RIB）</p><p><strong>数据平面</strong><br>网络设备的基本任务是处理和转发不同端口上各种类型的数据，对于数据处理过程中各种具体的处理转发过程，例如L2/L3/ACL/QOS/组播/安全防护等各功能的具体执行过程，都属于数据转发平面的任务范畴。数据转发平面在网络设备的各种平面任务当中需要占用决大部分的硬件资源，也直接地对其性能表现起决定作用，各个厂家都通过各种技术手段和芯片技术努力地提高网络设备数据平面的处理性能。<br>数据转发平面主要靠硬件资源来处理信息。<br>show ip cef 查看最终迭代的出接口，属数据平面范畴（转发信息数据库，FIB）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据平面，控制平面，管理平面&quot;&gt;&lt;a href=&quot;#数据平面，控制平面，管理平面&quot; class=&quot;headerlink&quot; title=&quot;数据平面，控制平面，管理平面&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://tjlxy.lofter.com/post/335f6
      
    
    </summary>
    
      <category term="microservice" scheme="https://talenhao.github.io/categories/microservice/"/>
    
    
      <category term="servicemesh" scheme="https://talenhao.github.io/tags/servicemesh/"/>
    
  </entry>
  
  <entry>
    <title>ibus rime特殊符号</title>
    <link href="https://talenhao.github.io/2019/12/24/ibus-rime%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://talenhao.github.io/2019/12/24/ibus-rime特殊符号/</id>
    <published>2019-12-24T09:31:54.000Z</published>
    <updated>2019-12-24T09:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ibus-rime-五笔输入法输入特殊符号编码表"><a href="#ibus-rime-五笔输入法输入特殊符号编码表" class="headerlink" title="ibus rime 五笔输入法输入特殊符号编码表"></a>ibus rime 五笔输入法输入特殊符号编码表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">码表：</span><br><span class="line">zzbd 标点符号     zzpy 拼音符号    zzts 特殊符号</span><br><span class="line">zzsx 数学符号     zzdx 单位符号    zzjt 箭头符号</span><br><span class="line">zzys 圆圈数字     zzpp 偏旁        zzds 带点数字</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ibus-rime-五笔输入法输入特殊符号编码表&quot;&gt;&lt;a href=&quot;#ibus-rime-五笔输入法输入特殊符号编码表&quot; class=&quot;headerlink&quot; title=&quot;ibus rime 五笔输入法输入特殊符号编码表&quot;&gt;&lt;/a&gt;ibus rime 五笔输入
      
    
    </summary>
    
      <category term="archlinux" scheme="https://talenhao.github.io/categories/archlinux/"/>
    
    
      <category term="ibus" scheme="https://talenhao.github.io/tags/ibus/"/>
    
  </entry>
  
  <entry>
    <title>microservice</title>
    <link href="https://talenhao.github.io/2019/12/23/microservice/"/>
    <id>https://talenhao.github.io/2019/12/23/microservice/</id>
    <published>2019-12-23T05:36:22.000Z</published>
    <updated>2019-12-23T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MicroService微服务"><a href="#MicroService微服务" class="headerlink" title="MicroService微服务"></a>MicroService微服务</h1><p><img src="../../../../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1.svg" alt="微服务"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MicroService微服务&quot;&gt;&lt;a href=&quot;#MicroService微服务&quot; class=&quot;headerlink&quot; title=&quot;MicroService微服务&quot;&gt;&lt;/a&gt;MicroService微服务&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../..
      
    
    </summary>
    
      <category term="service mesh" scheme="https://talenhao.github.io/categories/service-mesh/"/>
    
    
      <category term="service mesh" scheme="https://talenhao.github.io/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>Mysql DAL</title>
    <link href="https://talenhao.github.io/2019/12/23/Mysql-DAL/"/>
    <id>https://talenhao.github.io/2019/12/23/Mysql-DAL/</id>
    <published>2019-12-23T02:18:48.000Z</published>
    <updated>2019-12-23T02:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据访问层中间件（DAL）"><a href="#MySQL-数据访问层中间件（DAL）" class="headerlink" title="MySQL 数据访问层中间件（DAL）"></a>MySQL 数据访问层中间件（DAL）</h1><pre class="mermaid">graph TBclient-->altasclient-->mysql_routerclient-->mycataltas-->mastermysql_router-->mastermycat-->masteraltas-->slavemysql_router-->slavemycat-->slave</pre><pre class="mermaid">graph TBcobar-->mycat</pre><p>使用横向扩展，读写分离提升读性能</p><p>使用分库分表提升写性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-数据访问层中间件（DAL）&quot;&gt;&lt;a href=&quot;#MySQL-数据访问层中间件（DAL）&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据访问层中间件（DAL）&quot;&gt;&lt;/a&gt;MySQL 数据访问层中间件（DAL）&lt;/h1&gt;&lt;pre 
      
    
    </summary>
    
      <category term="uncategorized" scheme="https://talenhao.github.io/categories/uncategorized/"/>
    
    
      <category term="untags" scheme="https://talenhao.github.io/tags/untags/"/>
    
  </entry>
  
  <entry>
    <title>历年关键字</title>
    <link href="https://talenhao.github.io/2019/12/19/%E5%8E%86%E5%B9%B4%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://talenhao.github.io/2019/12/19/历年关键字/</id>
    <published>2019-12-19T07:31:52.000Z</published>
    <updated>2019-12-19T07:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><p><code>微服务</code></p><p><code>service mesh</code> <code>服务网格</code></p><p><code>serviceless</code></p><p><code>chaos enginering</code> <code>混沌工程</code></p><p><code>ant</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019&quot;&gt;&lt;a href=&quot;#2019&quot; class=&quot;headerlink&quot; title=&quot;2019&quot;&gt;&lt;/a&gt;2019&lt;/h1&gt;&lt;p&gt;&lt;code&gt;微服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;service mesh&lt;/code&gt; &lt;code&gt;服务网格&lt;/
      
    
    </summary>
    
      <category term="uncategorized" scheme="https://talenhao.github.io/categories/uncategorized/"/>
    
    
      <category term="untags" scheme="https://talenhao.github.io/tags/untags/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes学习笔记</title>
    <link href="https://talenhao.github.io/2019/11/27/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://talenhao.github.io/2019/11/27/kubernetes学习笔记/</id>
    <published>2019-11-27T11:26:34.000Z</published>
    <updated>2019-11-27T11:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><img src="../../../../images/docker-engine.png" alt="docker engine"></p><p>图片来自[<a href="https://www.qikqiak.com/k8s-book/docs/2.Docker%20%E7%AE%80%E4%BB%8B.html]" target="_blank" rel="noopener">https://www.qikqiak.com/k8s-book/docs/2.Docker%20%E7%AE%80%E4%BB%8B.html]</a>(<a href="https://www.qikqiak.com/k8s-book/docs/2.Docker" target="_blank" rel="noopener">https://www.qikqiak.com/k8s-book/docs/2.Docker</a> 简介.html)</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull [选项] [Docker Registry 地址[:端口]/]仓库名[:标签]</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t --rm 镜像:标签 /bin/bash</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run ubuntu:16.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span></span><br><span class="line">-d 后台运行</span><br><span class="line">docker commit修复运行的镜像读写层后提交</span><br></pre></td></tr></table></figure><p>列出镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/redis     latest              3c41ce05add9        5 months ago        95 MB</span><br></pre></td></tr></table></figure><p>当利用<code>docker run</code>来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层</p><ol><li>FROM 指定基础镜像<ol><li>官方高质量镜像</li><li>scratch 一个虚拟的镜像,表示空白</li></ol></li><li>RUN 运行命令(使用&amp;&amp;连接生成一层FS, 支持\ 换行 ,# 注释)<ol><li>shell:RUN &lt;命令&gt;</li><li>exec:RUN [“可执行文件”, “参数1”, “参数2”]</li></ol></li></ol><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>镜像构建上下文目录是相对engine来说的,不是本地的路径,必须改./开头.</p><p>使用-f可以指定任意名称的文件为dockerfile文件.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../images/docker-engine.png&quot; alt=&quot;d
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://talenhao.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://talenhao.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡后端检测</title>
    <link href="https://talenhao.github.io/2019/11/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%90%8E%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
    <id>https://talenhao.github.io/2019/11/13/负载均衡后端检测/</id>
    <published>2019-11-13T06:32:09.000Z</published>
    <updated>2019-11-13T06:32:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx后端检测"><a href="#nginx后端检测" class="headerlink" title="nginx后端检测"></a>nginx后端检测</h2><p>默认没有踢除功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nginx后端检测&quot;&gt;&lt;a href=&quot;#nginx后端检测&quot; class=&quot;headerlink&quot; title=&quot;nginx后端检测&quot;&gt;&lt;/a&gt;nginx后端检测&lt;/h2&gt;&lt;p&gt;默认没有踢除功能&lt;/p&gt;

      
    
    </summary>
    
      <category term="负载均衡" scheme="https://talenhao.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="lvs,nginx,haproxy" scheme="https://talenhao.github.io/tags/lvs-nginx-haproxy/"/>
    
  </entry>
  
  <entry>
    <title>linux资源管理</title>
    <link href="https://talenhao.github.io/2019/11/13/linux%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://talenhao.github.io/2019/11/13/linux资源管理/</id>
    <published>2019-11-13T04:04:10.000Z</published>
    <updated>2019-11-13T04:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>单进程-&gt;FD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用户单进程的最大文件数，用户登录时生效</span><br><span class="line">echo &apos;* soft nofile 1048576&apos; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &apos;* hard nofile 1048576&apos; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">ulimit -n 1048576 #用户单进程的最大文件描述符数 当前会话生效</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;单进程-&amp;gt;FD&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="linux" scheme="https://talenhao.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talenhao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>tcp/ip</title>
    <link href="https://talenhao.github.io/2019/11/13/tcp-ip/"/>
    <id>https://talenhao.github.io/2019/11/13/tcp-ip/</id>
    <published>2019-11-13T03:01:53.000Z</published>
    <updated>2019-11-13T03:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP协议源端口与目标端口分别占用2个字节(16个bit),共可存储2^16=65536个端口.去掉1024个系统保留端口,可用64512个端口.</p><p>一个客户端共可发起64512个TCP连接</p><p>服务端没有数量限制,取决于内存,CPU资源限制.服务端的TCP连接数为: socket fd(clientip:65412)*N.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端口号&quot;&gt;&lt;a href=&quot;#端口号&quot; class=&quot;headerlink&quot; title=&quot;端口号&quot;&gt;&lt;/a&gt;端口号&lt;/h2&gt;&lt;p&gt;TCP协议源端口与目标端口分别占用2个字节(16个bit),共可存储2^16=65536个端口.去掉1024个系统保留端口,可用64
      
    
    </summary>
    
      <category term="tcpip" scheme="https://talenhao.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip" scheme="https://talenhao.github.io/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://talenhao.github.io/2019/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://talenhao.github.io/2019/11/10/数据结构/</id>
    <published>2019-11-10T02:06:56.000Z</published>
    <updated>2019-11-10T02:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures 数据结构"></a>Data Structures 数据结构</h1><h2 id="heep-堆"><a href="#heep-堆" class="headerlink" title="heep(堆)"></a>heep(堆)</h2><p>堆(heap)又被为优先队列(priority queue),但并不是队列(按先后顺序).堆是按优先级dequeue(出队),enqueue(入队).</p><p>“堆”是实现调度器的理想数据结构。(Linux中可以使用nice命令来影响进程的优先级)</p><p>堆通常是一个可以被看做一棵完全二叉树(complete binary tree)的数组对象(二叉堆(binary heap)</p><p>堆顶的优先级高,堆的主要操作是插入和删除最小元素(元素值本身为优先级键值，小元素享有高优先级)。</p><ol><li><p>新加入的节点加入底部,与父节点比较优先级大小,比父节点小就交换.(percolate_up)</p></li><li><p>删除根节点后生成两个子树,重构堆(percolate_down).将lasted做为根连接子树</p></li></ol><p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p><p>堆的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个元素的序列&#123;k1,k2,ki,…,kn&#125;当且仅当满足下关系时，称之为堆。</span><br><span class="line">(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4...n/2)</span><br></pre></td></tr></table></figure><p>在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：</p><ol><li><p>事先不知道程序所需对象的数量和大小。</p></li><li><p>对象太大，不适合使用堆栈分配器。</p></li></ol><p>堆使用运行期间分配给代码和堆栈以外的部分内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算公式</span><br><span class="line">parent(i) = floor((i - 1)/2)</span><br><span class="line">left(i)   = 2i + 1</span><br><span class="line">right(i)  = 2i + 2</span><br></pre></td></tr></table></figure><p>这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要<strong>O(1)</strong>的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-Structures-数据结构&quot;&gt;&lt;a href=&quot;#Data-Structures-数据结构&quot; class=&quot;headerlink&quot; title=&quot;Data Structures 数据结构&quot;&gt;&lt;/a&gt;Data Structures 数据结构&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="dataStructures" scheme="https://talenhao.github.io/categories/dataStructures/"/>
    
    
      <category term="dataStructures" scheme="https://talenhao.github.io/tags/dataStructures/"/>
    
  </entry>
  
  <entry>
    <title>react</title>
    <link href="https://talenhao.github.io/2019/11/05/react/"/>
    <id>https://talenhao.github.io/2019/11/05/react/</id>
    <published>2019-11-05T02:51:13.000Z</published>
    <updated>2019-11-05T02:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-遍历"><a href="#react-遍历" class="headerlink" title="react 遍历"></a>react 遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.data.map(</span><br><span class="line">  (item, index)=&gt;&#123;</span><br><span class="line">    item.key = index;</span><br><span class="line">    return item;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="antd-table"><a href="#antd-table" class="headerlink" title="antd table"></a>antd table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const columns</span><br><span class="line">const dataSource</span><br><span class="line">const rowSelection</span><br></pre></td></tr></table></figure><h2 id="CROS"><a href="#CROS" class="headerlink" title="CROS"></a>CROS</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at 'http://127.0.0.1:8000/api/imooc/order/' from origin 'http://127.0.0.1:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://127.0.0.1:3000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pip install django djangorestframework django-cors-headers</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'corsheaders',</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">...</span><br><span class="line">    'corsheaders.middleware.CorsMiddleware'</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL=True</span><br><span class="line">或</span><br><span class="line">CORS_ORIGIN_WHITELIST = [</span><br><span class="line">    'google.com',</span><br><span class="line">    'hostname.example.com',</span><br><span class="line">    'localhost:8000',</span><br><span class="line">    '127.0.0.1:9000'</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="index-js-1375-Warning-Failed-prop-type-Invalid-prop-id-of-type-array-supplied-to-Select-expected-string"><a href="#index-js-1375-Warning-Failed-prop-type-Invalid-prop-id-of-type-array-supplied-to-Select-expected-string" class="headerlink" title="index.js:1375 Warning: Failed prop type: Invalid prop id of type array supplied to Select, expected string."></a>index.js:1375 Warning: Failed prop type: Invalid prop <code>id</code> of type <code>array</code> supplied to <code>Select</code>, expected <code>string</code>.</h2><h3 id="expected-to-return-a-value-in-arrow-function-array-callback-return"><a href="#expected-to-return-a-value-in-arrow-function-array-callback-return" class="headerlink" title="expected to return a value in arrow function array-callback-return"></a>expected to return a value in arrow function array-callback-return</h3><p>A <code>map()</code> creates an array, so a <code>return</code> is expected for all code paths (if/elses).</p><p>If you don’t want an array or to return data, use <code>forEach</code> instead.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-遍历&quot;&gt;&lt;a href=&quot;#react-遍历&quot; class=&quot;headerlink&quot; title=&quot;react 遍历&quot;&gt;&lt;/a&gt;react 遍历&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="front-end" scheme="https://talenhao.github.io/categories/front-end/"/>
    
    
      <category term="react" scheme="https://talenhao.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel</title>
    <link href="https://talenhao.github.io/2019/11/01/Linux-kernel/"/>
    <id>https://talenhao.github.io/2019/11/01/Linux-kernel/</id>
    <published>2019-11-01T10:05:31.000Z</published>
    <updated>2019-11-01T10:05:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li>文件</li><li>目录</li><li>链接</li><li>块设备</li><li>字符设备</li><li>管道</li><li>套接字</li></ol><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>inode惟一索引</p><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Fri Nov 01 talen@tp hexo.blog]$ <span class="built_in">stat</span> yarn.lock</span><br><span class="line">File: yarn.lock</span><br><span class="line">Size: 97141           Blocks: 192        IO Block: 4096   regular file</span><br><span class="line">Device: 803h/2051d      Inode: 42116468    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/   talen)   Gid: (  985/   users)</span><br><span class="line">Access: 2019-09-16 17:39:57.848034466 +0800</span><br><span class="line">Modify: 2019-07-24 20:51:25.073555443 +0800</span><br><span class="line">Change: 2019-07-24 20:51:25.073555443 +0800</span><br><span class="line">Birth: 2019-07-24 20:51:25.073555443 +0800</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><h5 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h5><ol><li>owner</li><li>group</li><li>other</li></ol><h5 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h5><ol><li>读r</li><li>写w</li><li>执行x</li><li>suid : 进程执行时获取文件拥有者uid的权限</li><li>sgid: 进行执行时获取文件拥有者用户组gid的权限 </li><li>sticky: 向kernel发送一个请求,进程结束后保留在内存中.</li></ol><h4 id="文件内核系统调用"><a href="#文件内核系统调用" class="headerlink" title="文件内核系统调用"></a>文件内核系统调用</h4><p>创建一个文件对象,包含文件指针(使用lseek()改变文件指针位置)</p><ol><li>打开<ol><li>fd = open(path, flag, mode) # 参数分别对应 路径,操作,权限</li></ol></li><li>创建</li><li>访问<ol><li>顺序<ol><li>设备文件</li><li>管道</li></ol></li><li>随机<ol><li>普通文件</li></ol></li><li>read() and write()<ol><li>nread = read(fd, buf, count)</li><li>nwrite = write(fd, buf, count)</li></ol></li><li>close<ol><li>res = close(fd)</li></ol></li></ol></li><li>文件指针<ol><li>newoffset=lseek(fd, offset, whence)</li></ol></li><li>删除,生命名文件不需要打开<ol><li>res = rename(oldpath, newpath)</li><li>res = unlink(pathname)</li></ol></li></ol><h3 id="文件描述符FD"><a href="#文件描述符FD" class="headerlink" title="文件描述符FD"></a>文件描述符FD</h3><p>是进程-&gt;文件描述符FD-&gt;文件对象</p><ol><li>同一进程可有多个FD</li><li>多个进程可以同时操作一个文件,系统不提供同步</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h3><p>单处理器,同一时间只有一个进程在运行,用户态的进程调用系统调用后切换到内核态</p><ol><li>用户态<ol><li>|用户态进程调用系统调用切换到内核态</li><li>进程CPU发出异常信号,内核代表产生异常的进程处理异常</li><li>外围设备发出中断请求</li><li>内核进程被执行</li></ol></li><li>内核态</li></ol><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>进程描述符</p><p>进程暂停时,几个相关的处理器寄存器保存在进程描述符中</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>system V ipc</p><ol><li>信号量</li><li>消息队列 POSIX消息队列 </li><li>共享内存</li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>fork() 父创建新进程<ol><li>wait4()等待子进程退出,返回子进程pid</li><li>init特殊进程管理所有子进程</li></ol></li><li>_exit() 退出进程</li><li>exec() 装入一个新程序</li></ol><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间.</p><p>可用于进程间共享数据</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>硬件-&gt;虚拟内存-&gt;进程</p><h3 id="随机访问存储器RAM"><a href="#随机访问存储器RAM" class="headerlink" title="随机访问存储器RAM"></a>随机访问存储器RAM</h3><p>内核映像+虚拟内存</p><p>平衡每个内存请求,并在达到阀值时调用页框回收(page frame reclaiming)算法释放其它内存</p><ol><li>内核映像:<ol><li>内核代码</li><li>内核静态数据结构</li></ol></li><li>虚拟内存:<ol><li>内核缓冲区,描述符,动态数据结构</li><li>进程内存请求</li><li>高速缓存</li></ol></li></ol><h3 id="内核内存分配器KMA"><a href="#内核内存分配器KMA" class="headerlink" title="内核内存分配器KMA"></a>内核内存分配器KMA</h3><p>虚拟内存系统一个主要问题是内存碎片</p><ol><li>快</li><li>利用率高,浪费少,碎片少</li><li>与其它内存管理子系统配合</li></ol><p><code>linux在众多算法中选择了solaris的slab分配算法</code></p><h3 id="进程的虚拟地址空间处理"><a href="#进程的虚拟地址空间处理" class="headerlink" title="进程的虚拟地址空间处理"></a>进程的虚拟地址空间处理</h3><p>内核使用一组内存区描述符描述虚拟地址空间.进程通过exec()系统调用开始执行.</p><p>描述符区:</p><ol><li>代码区</li><li>初始化数据</li><li>未初始化数据</li><li>程序栈</li><li>共享库代码及数据</li><li>堆(动态内存)</li></ol><p>请求调页,写时复制</p><p>高速缓存 sync()将脏数据写回磁盘</p><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>kernel-&gt;驱动-&gt;I/O设备</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;块设备&lt;/li&gt;
&lt;li&gt;字符设备&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;套接字&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h3&gt;&lt;p&gt;inode惟一索引&lt;/p&gt;
&lt;h4 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Fri Nov 01 talen@tp hexo.blog]$ &lt;span class=&quot;built_in&quot;&gt;stat&lt;/span&gt; yarn.lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File: yarn.lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Size: 97141           Blocks: 192        IO Block: 4096   regular file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Device: 803h/2051d      Inode: 42116468    Links: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access: (0644/-rw-r--r--)  Uid: ( 1000/   talen)   Gid: (  985/   users)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access: 2019-09-16 17:39:57.848034466 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Modify: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Change: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Birth: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="https://talenhao.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talenhao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>javascript 学习</title>
    <link href="https://talenhao.github.io/2019/09/28/javascript-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://talenhao.github.io/2019/09/28/javascript-学习/</id>
    <published>2019-09-28T13:24:14.000Z</published>
    <updated>2019-09-28T13:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>html是结构,CSS是表示,js是动态</p><pre class="mermaid">graph TBES5ES6node(node.js ES服务端运行环境)ES6-->babel(babel转码器)babel-->ES5less-->cssjsonp[jsonp可以跨域]-->apiaxios[axios不能跨域]-->api</pre><p>一个变量,多个数组</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量要先声明再赋值</strong></p><p>变量名规范:</p><ol><li>必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字</li><li><strong>变量名区分大小写</strong></li><li>不允许使用JavaScript关键字和保留字做变量名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名,变量<span class="number">2</span>,变量n; <span class="comment">//变量需要声明</span></span><br><span class="line"><span class="keyword">var</span> mychar;</span><br><span class="line">mychar=<span class="string">"javascript"</span>;</span><br><span class="line"><span class="keyword">var</span> mynum = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>输出变量,字符串可以使用+号串连</p><p>ES6增加let代码块作用域变量</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>创建数组语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myarray=new Array(num); //num是数组初始长度,可为空, 可扩展</span><br></pre></td></tr></table></figure><p>数组赋值:</p><p>JS的数组中添加元素只需要使用未使用的索引即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//定义数组</span></span><br><span class="line"> myarr[<span class="number">0</span>]=<span class="number">80</span>; </span><br><span class="line"> myarr[<span class="number">1</span>]=<span class="number">60</span>;</span><br><span class="line"> myarr[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="keyword">var</span> myarray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>);<span class="comment">//创建数组同时赋值</span></span><br><span class="line"><span class="keyword">var</span> myarray = [<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>];<span class="comment">//直接输入一个数组（称 “字面量数组”）</span></span><br></pre></td></tr></table></figure><p>数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray.length; <span class="comment">//获得数组myarray的长度</span></span><br></pre></td></tr></table></figure><p>数组的维度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一维数组的表示: myarray[ ]</span><br><span class="line">二维数组的表示: myarray[ ][ ]</span><br><span class="line"><span class="keyword">var</span> Myarr = [[<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>]]</span><br><span class="line">myarr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">5</span>; <span class="comment">//将5的值传入到数组中，覆盖原有值。说明: myarr[0][1] ,0 表示表的行，1表示表的列。</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>算术操作符(+、-、*、/等)，比较操作符(&lt;、&gt;、&gt;=、&lt;=等)，逻辑操作符(&amp;&amp;、||、！)</p><p>自加一<code>“++”</code>；自减一<code>“--”</code></p><p><strong>操作符之间的优先级（高到低）:</strong></p><p>算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</p><h2 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)</span><br><span class="line">&#123; 条件<span class="number">1</span>成立时执行的代码&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>(条件<span class="number">2</span>)</span><br><span class="line">&#123; 条件<span class="number">2</span>成立时执行的代码&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>(条件n)</span><br><span class="line">&#123; 条件n成立时执行的代码&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; 条件<span class="number">1</span>、<span class="number">2</span>至n不成立时执行的代码&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有很多种选项的时候，switch比if else使用更方便。</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>值<span class="number">1</span>:</span><br><span class="line">  执行代码块 <span class="number">1</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>值<span class="number">2</span>:</span><br><span class="line">  执行代码块 <span class="number">2</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span>值n:</span><br><span class="line">  执行代码块 n</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  与 <span class="keyword">case</span>值<span class="number">1</span> 、 <span class="keyword">case</span>值<span class="number">2.</span>..case值n 不同时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化变量;循环条件;循环迭代)</span><br><span class="line">&#123;     </span><br><span class="line">    循环语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断条件)</span><br><span class="line">&#123;</span><br><span class="line">    循环语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="comment">//先执行一次再循环</span></span><br><span class="line">&#123;</span><br><span class="line">    循环语句</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">while</span>(判断条件)</span><br></pre></td></tr></table></figure><p>break语句退出当前循环，直接执行后面的代码</p><p>continue的作用是仅仅跳过本次循环</p><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>函数定义后需要调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure><h2 id="JavaScript-警告（alert-消息对话框）"><a href="#JavaScript-警告（alert-消息对话框）" class="headerlink" title="JavaScript-警告（alert 消息对话框）"></a>JavaScript-警告（alert 消息对话框）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><h2 id="JavaScript-确认（confirm-消息对话框）"><a href="#JavaScript-确认（confirm-消息对话框）" class="headerlink" title="JavaScript-确认（confirm 消息对话框）"></a>JavaScript-确认（confirm 消息对话框）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: Boolean值</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击&quot;确定&quot;按钮时，返回true</span><br><span class="line">当用户点击&quot;取消&quot;按钮时，返回false</span><br></pre></td></tr></table></figure><h2 id="JavaScript-提问（prompt-消息对话框）"><a href="#JavaScript-提问（prompt-消息对话框）" class="headerlink" title="JavaScript-提问（prompt 消息对话框）"></a>JavaScript-提问（prompt 消息对话框）</h2><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line">2. 点击取消按钮，将返回null</span><br></pre></td></tr></table></figure><h2 id="JavaScript-打开新窗口（window-open）"><a href="#JavaScript-打开新窗口（window-open）" class="headerlink" title="JavaScript-打开新窗口（window.open）"></a>JavaScript-打开新窗口（window.open）</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    1.该名称由字母、数字和下划线字符组成。</span><br><span class="line">    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">   4.name 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><img src="../../../../images/52e3677900013d6a05020261.jpg" alt="img"></strong></p><h2 id="JavaScript-关闭窗口（window-close）"><a href="#JavaScript-关闭窗口（window-close）" class="headerlink" title="JavaScript-关闭窗口（window.close）"></a>JavaScript-关闭窗口（window.close）</h2><p>close()关闭窗口</p><p><strong>用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close();   //关闭本窗口</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   //关闭指定的窗口</span><br></pre></td></tr></table></figure><h2 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h2><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><img src="../../../../images/52e4bd0f0001dd8d04830279.jpg" alt="img"></p><p><strong>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</strong></p><p>&lt;元素标签 属性&gt;文本&lt;元素&gt;</p><p>为元素标签配置惟一ID属性,通过ID获取元素</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(“id”)</span><br></pre></td></tr></table></figure><p><strong>结果:null</strong>或[<strong>object HTMLParagraphElement]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object.innerHTML; //获取/修改元素的内容</span><br><span class="line"></span><br><span class="line">Object.style.property=new style; //修改元素的CSS样式</span><br><span class="line">&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   var mychar = document.getElementById(&quot;pcon&quot;);</span><br><span class="line">   mychar.style.color=&quot;red&quot;;</span><br><span class="line">   mychar.style.fontSize=&quot;20&quot;;</span><br><span class="line">   mychar.style.backgroundColor =&quot;blue&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Object.style.display = none/block；//显示或隐藏对象</span><br><span class="line"></span><br><span class="line">object.className = classname; //配置对象类名</span><br></pre></td></tr></table></figure><p><img src="../../../../images/52e4d4240001dd6c04850229.jpg" alt="img"></p><p>整理链接:<a href="https://www.imooc.com/code/468" target="_blank" rel="noopener">https://www.imooc.com/code/468</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;html是结构,CSS是表示,js是动态&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph TB
ES5
ES6
node(node.js ES服务端运行环境)
ES6--&gt;babel(babel转码器)
babel--&gt;ES5
less--&gt;css
jsonp
      
    
    </summary>
    
      <category term="front-end" scheme="https://talenhao.github.io/categories/front-end/"/>
    
    
      <category term="front-end" scheme="https://talenhao.github.io/tags/front-end/"/>
    
      <category term="javascript" scheme="https://talenhao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>英语历史</title>
    <link href="https://talenhao.github.io/2019/09/19/%E8%8B%B1%E8%AF%AD%E5%8E%86%E5%8F%B2/"/>
    <id>https://talenhao.github.io/2019/09/19/英语历史/</id>
    <published>2019-09-19T09:11:18.000Z</published>
    <updated>2019-09-19T09:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语历史"><a href="#英语历史" class="headerlink" title="英语历史"></a>英语历史</h1><pre class="mermaid">graph TB腓尼基字母-->希腊字母希腊字母-->拉丁字母拉丁字母-->英文字母</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;英语历史&quot;&gt;&lt;a href=&quot;#英语历史&quot; class=&quot;headerlink&quot; title=&quot;英语历史&quot;&gt;&lt;/a&gt;英语历史&lt;/h1&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB
腓尼基字母--&gt;希腊字母
希腊字母--&gt;拉丁字母
拉丁字母--&gt;英文字
      
    
    </summary>
    
      <category term="english" scheme="https://talenhao.github.io/categories/english/"/>
    
    
      <category term="english" scheme="https://talenhao.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>浏览器攻击</title>
    <link href="https://talenhao.github.io/2019/09/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%BB%E5%87%BB/"/>
    <id>https://talenhao.github.io/2019/09/11/浏览器攻击/</id>
    <published>2019-09-11T01:51:49.000Z</published>
    <updated>2019-09-11T01:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器跨域"><a href="#浏览器跨域" class="headerlink" title="浏览器跨域"></a>浏览器跨域</h2><p>JavaScript出于<em>安全</em>方面的考虑做的<em>同源</em>策略的<em>限制</em>，不允许<em>跨域</em>访问其他资源。跨域请求成功后，浏览器会拦截服务器端返回的结果</p><p>同源:<code>域名、协议、端口均相同。举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略）</code></p><a id="more"></a><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>攻击者指挥用户攻击目标网站</p><pre class="mermaid">graph LRuser-->|1,username&password|target(目标网站)target-->|2,OK&set cookie|useruser-.->|3,目标cookie存在,访问攻击者站点|tacker[攻击者站点]tacker-.->|4,让用户请求目标网站执行特定操作|useruser-.->|5,利用自己的权限做攻击操作|target</pre><pre class="mermaid">sequenceDiagramparticipant attacker as 攻击者站点participant user as 用户participant target as 目标站点user->>+target:1,request,username&passwordtarget-->>user:2,response,set-cookieuser->>+attacker:3,request,请求攻击者站点attacker-->>-user:4,response,指挥用户访问目标站点user->>-target:5,request,利用自己的权限发起攻击操作</pre><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>伪装用户自己发起攻击</p><pre class="mermaid">sequenceDiagramparticipant attacker as 攻击者站点participant user as 用户participant target as 目标站点attacker-->>user:1,request,发送含有攻击代码的目标站点链接user->>+target:2,request,携带攻击代码,请求目标站点target-->>user:3,response,目标站点执行后返回用户数据user->>attacker:4,request,在用户不知情时将cookie,session发送给攻击者attacker->>-target:5,request,伪装用户访问目标站点</pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器跨域&quot;&gt;&lt;a href=&quot;#浏览器跨域&quot; class=&quot;headerlink&quot; title=&quot;浏览器跨域&quot;&gt;&lt;/a&gt;浏览器跨域&lt;/h2&gt;&lt;p&gt;JavaScript出于&lt;em&gt;安全&lt;/em&gt;方面的考虑做的&lt;em&gt;同源&lt;/em&gt;策略的&lt;em&gt;限制&lt;/em&gt;，不允许&lt;em&gt;跨域&lt;/em&gt;访问其他资源。跨域请求成功后，浏览器会拦截服务器端返回的结果&lt;/p&gt;
&lt;p&gt;同源:&lt;code&gt;域名、协议、端口均相同。举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略）&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="safe" scheme="https://talenhao.github.io/categories/safe/"/>
    
    
      <category term="safe" scheme="https://talenhao.github.io/tags/safe/"/>
    
  </entry>
  
  <entry>
    <title>监控系统预测和异常判断</title>
    <link href="https://talenhao.github.io/2019/09/06/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E9%A2%84%E6%B5%8B%E5%92%8C%E5%BC%82%E5%B8%B8%E5%88%A4%E6%96%AD/"/>
    <id>https://talenhao.github.io/2019/09/06/监控系统预测和异常判断/</id>
    <published>2019-09-06T07:08:23.000Z</published>
    <updated>2019-09-06T07:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控系统预测和异常判断"><a href="#监控系统预测和异常判断" class="headerlink" title="监控系统预测和异常判断"></a>监控系统预测和异常判断</h1><p>基于算法的 IT 运维平台(Algorithmic IT operations platforms)</p><ol><li>机器学习</li><li>数学统计<ol><li>方差分析可以用来判断几组观察到的数据或者处理的结果是否存在显著差异。</li><li>在方差分析中，我们把要考察其均值是否存在显著差异的指标变量称为响应变量，对响应变量取值有影响的其他变量称为因素。例如，信用卡消费水平和治疗效果为响应变量，地区和药品则为因素。在方差分析中，因素的取值应为离散型的，其不同的取值称为水平。例如，每一个具体地区或者每一种药品都对应着一个水平。根据因素的个数，方差分析可以分为单因素方差分析和多因素方差分析</li><li><strong>正态分布像一只倒扣的钟。两头低，中间高，左右对称。大部分数据集中在平均值，小部分在两端。</strong></li></ol></li></ol><h2 id="异常判断"><a href="#异常判断" class="headerlink" title="异常判断"></a>异常判断</h2><p>指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。</p><a id="more"></a><h3 id="异常算法"><a href="#异常算法" class="headerlink" title="异常算法"></a>异常算法</h3><p>skyline 一共提供了 7 个异常检测算法，如果有 5 个以上认为是异常，那么 skyline就认为这个序列异常了.</p><p>异常检测算法实际写在了 <code>src/analyzer/algorithms.py</code></p><ol><li>first_hour_average、</li><li>simple_stddev_from_moving_average、</li><li>stddev_from_moving_average、</li><li>mean_subtraction_cumulation、</li><li>least_squares</li><li>histogram_bins、</li><li>grubbs、</li><li>median_absolute_deviation、</li><li>Kolmogorov-Smirnov_test</li></ol><h3 id="first-hour-average"><a href="#first-hour-average" class="headerlink" title="first_hour_average"></a>first_hour_average</h3><p>这是最简单的。先求本周期内最前面的第一个小时的平均值和标准差，然后和最新的三个值的平均值(tail_avg()，这是后面多数算法都通用的做法)做比较。如果 tail_avg 和 第一小时平均值的差距大于 3 倍的标准差，那么认定为异常。</p><h3 id="simple-stddev-from-moving-average"><a href="#simple-stddev-from-moving-average" class="headerlink" title="simple_stddev_from_moving_average"></a>simple_stddev_from_moving_average</h3><p>把上面算法的范围扩大化，求的是整个周期内全部数据的平均值和标准差。</p><h3 id="stddev-from-moving-average"><a href="#stddev-from-moving-average" class="headerlink" title="stddev_from_moving_average"></a>stddev_from_moving_average</h3><p>在上面算法的基础上，采用指数加权移动平均值。对周期内采点数量较少的情况更好一些。</p><h3 id="mean-subtraction-cumulation"><a href="#mean-subtraction-cumulation" class="headerlink" title="mean_subtraction_cumulation"></a>mean_subtraction_cumulation</h3><p>做法是这样的：</p><ol><li>排除最后一个值；</li><li>求剩余序列的平均值；</li><li>全序列减去上面这个平均值；</li><li>求剩余序列的标准差；</li><li>判断全序列最后一个值是否大于 3 倍的标准差</li></ol><p>在代码中本来还计算了一次序列的指数加权移动平均值，但是算完了却没用，感觉怪怪的。</p><h3 id="least-squares"><a href="#least-squares" class="headerlink" title="least_squares"></a>least_squares</h3><p>采用最小二乘法拟近时间序列，然后用实际值减去拟近值得到新序列。然后判断新序列的最后三个值的平均值是否大于 3 倍的新序列标准差。</p><p>所谓最小二乘法，简单说就是对一个 [x, y] 序列，会有一对常数 [m, c]，让 Y = mx + c 等式中的 Y 和 y 在全序列上最接近。</p><h3 id="histogram-bins"><a href="#histogram-bins" class="headerlink" title="histogram_bins"></a>histogram_bins</h3><p>将整个周期序列的数据按照直方图统计法归入 15 个直方中，然后看最后三个值的平均值属于这 15 个直方的具体哪个。如果这个直方中包含的数据小于 20 个，判断为异常。</p><p>从算法中可以知道，如果周期内数据量不够，很容易被判断为异常的。</p><h3 id="grubbs"><a href="#grubbs" class="headerlink" title="grubbs"></a>grubbs</h3><p>将整个周期序列的数据按照格拉布斯法求异常值。</p><p>标准的格拉布斯法是这样的：</p><ol><li>从小到大排序；</li><li>求序列的平均值和标准差；</li><li>计算最小值和最大值与平均值的差距，更大的那个为可疑值；</li><li>可疑值减去平均值，再除以标准差，如果大于格拉布斯临界值，那么就是异常值；</li><li>排除异常值，对剩余序列循环做 1-5 步骤。</li></ol><p>这里只用判断时间序列的最后是否异常，所以直接将最后三个值的平均值作为可疑值判断是否异常即可。</p><p><strong>2013 年 07 月 23 日更新</strong></p><p>新增了一个异常算法，现在有 8 个了，要通过 6 个才算真异常。</p><p>新增的是”绝对中值偏差法”</p><h3 id="median-absolute-deviation"><a href="#median-absolute-deviation" class="headerlink" title="median_absolute_deviation"></a>median_absolute_deviation</h3><p>具体实现是：序列的最后一个值，比该序列的绝对中值大 6 倍以上，即判断为异常。</p><p>注意这里是中值，不是平均值。</p><p><strong>2013 年 08 月 14 日更新</strong></p><p>新增一个异常算法，现在有 9 个了。</p><p>新增的是”柯尔莫诺夫-斯米尔诺夫检验法”</p><h3 id="Kolmogorov-Smirnov-test"><a href="#Kolmogorov-Smirnov-test" class="headerlink" title="Kolmogorov-Smirnov_test"></a>Kolmogorov-Smirnov_test</h3><p>具体实现是：计算序列内最近十分钟的数值的ks测试分布，然后计算序列中最近一个小时前到十分钟前这 50 分钟的数值的ks测试分布；如果两个分布相差较大，即判断为异常。</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><h3 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h3><p>时序存储</p><p> rrdtool 和 graphite</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;监控系统预测和异常判断&quot;&gt;&lt;a href=&quot;#监控系统预测和异常判断&quot; class=&quot;headerlink&quot; title=&quot;监控系统预测和异常判断&quot;&gt;&lt;/a&gt;监控系统预测和异常判断&lt;/h1&gt;&lt;p&gt;基于算法的 IT 运维平台(Algorithmic IT operations platforms)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;数学统计&lt;ol&gt;
&lt;li&gt;方差分析可以用来判断几组观察到的数据或者处理的结果是否存在显著差异。&lt;/li&gt;
&lt;li&gt;在方差分析中，我们把要考察其均值是否存在显著差异的指标变量称为响应变量，对响应变量取值有影响的其他变量称为因素。例如，信用卡消费水平和治疗效果为响应变量，地区和药品则为因素。在方差分析中，因素的取值应为离散型的，其不同的取值称为水平。例如，每一个具体地区或者每一种药品都对应着一个水平。根据因素的个数，方差分析可以分为单因素方差分析和多因素方差分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正态分布像一只倒扣的钟。两头低，中间高，左右对称。大部分数据集中在平均值，小部分在两端。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;异常判断&quot;&gt;&lt;a href=&quot;#异常判断&quot; class=&quot;headerlink&quot; title=&quot;异常判断&quot;&gt;&lt;/a&gt;异常判断&lt;/h2&gt;&lt;p&gt;指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。&lt;/p&gt;
    
    </summary>
    
      <category term="monitor" scheme="https://talenhao.github.io/categories/monitor/"/>
    
    
      <category term="monitor,alert" scheme="https://talenhao.github.io/tags/monitor-alert/"/>
    
  </entry>
  
  <entry>
    <title>keepalived</title>
    <link href="https://talenhao.github.io/2019/09/04/keepalived/"/>
    <id>https://talenhao.github.io/2019/09/04/keepalived/</id>
    <published>2019-09-04T03:01:41.000Z</published>
    <updated>2019-09-04T03:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h1><pre class="mermaid">graph TBkeepalived_module-->corekeepalived_module-->checkkeepalived_module-->vrrp</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;keepalived&quot;&gt;&lt;a href=&quot;#keepalived&quot; class=&quot;headerlink&quot; title=&quot;keepalived&quot;&gt;&lt;/a&gt;keepalived&lt;/h1&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB
keepalived_
      
    
    </summary>
    
      <category term="lb" scheme="https://talenhao.github.io/categories/lb/"/>
    
    
      <category term="lb,keepalived" scheme="https://talenhao.github.io/tags/lb-keepalived/"/>
    
  </entry>
  
  <entry>
    <title>VRRP协议</title>
    <link href="https://talenhao.github.io/2019/09/04/VRRP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://talenhao.github.io/2019/09/04/VRRP协议/</id>
    <published>2019-09-04T01:42:41.000Z</published>
    <updated>2019-09-04T01:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VRRP协议"><a href="#VRRP协议" class="headerlink" title="VRRP协议"></a>VRRP协议</h1><p>Skew time(秒)=(256－Backup路由器的优先级)/256</p><p>Master_Down_Interval(秒)=(3×VRRP报文的发送时间间隔)+Skew time</p><pre class="mermaid">sequenceDiagramparticipant up as 上层路由器participant m as master routerNote left of m: 00-00-5E-00-01-{VRID} & VIP & 优先级participant s as backup routerloop intervalm-->>s: vrrp 通告报文 I'm alive!endloop intervals-->>m:BFD检测快速切换endloop intervalm-->>up:NQA检测调整自身优先级end</pre><a id="more"></a><pre class="mermaid">graph TBvr((virtual_router))-->rr0((real_router_0))vr-->rr1((real_router_1))vr-->rr2((real_router_2))</pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;VRRP协议&quot;&gt;&lt;a href=&quot;#VRRP协议&quot; class=&quot;headerlink&quot; title=&quot;VRRP协议&quot;&gt;&lt;/a&gt;VRRP协议&lt;/h1&gt;&lt;p&gt;Skew time(秒)=(256－Backup路由器的优先级)/256&lt;/p&gt;
&lt;p&gt;Master_Down_Interval(秒)=(3×VRRP报文的发送时间间隔)+Skew time&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;sequenceDiagram
participant up as 上层路由器
participant m as master router
Note left of m: 00-00-5E-00-01-{VRID} &amp; VIP &amp; 优先级
participant s as backup router

loop interval
m--&gt;&gt;s: vrrp 通告报文 I&#39;m alive!
end
loop interval
s--&gt;&gt;m:BFD检测快速切换
end
loop interval
m--&gt;&gt;up:NQA检测调整自身优先级
end&lt;/pre&gt;
    
    </summary>
    
      <category term="network" scheme="https://talenhao.github.io/categories/network/"/>
    
    
      <category term="network,vrrp" scheme="https://talenhao.github.io/tags/network-vrrp/"/>
    
  </entry>
  
  <entry>
    <title>pgp加密</title>
    <link href="https://talenhao.github.io/2019/09/01/pgp%E5%8A%A0%E5%AF%86/"/>
    <id>https://talenhao.github.io/2019/09/01/pgp加密/</id>
    <published>2019-09-01T04:28:35.000Z</published>
    <updated>2019-09-01T04:28:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pgp加密"><a href="#pgp加密" class="headerlink" title="pgp加密"></a>pgp加密</h1><p>GnuPG 是一个用来进行非对称加密(PGP)的免费软件，简称GPG</p><p>PGP是一个基于RSA公匙加密体系的邮件加密软件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pgp加密&quot;&gt;&lt;a href=&quot;#pgp加密&quot; class=&quot;headerlink&quot; title=&quot;pgp加密&quot;&gt;&lt;/a&gt;pgp加密&lt;/h1&gt;&lt;p&gt;GnuPG 是一个用来进行非对称加密(PGP)的免费软件，简称GPG&lt;/p&gt;
&lt;p&gt;PGP是一个基于RSA公匙加密体
      
    
    </summary>
    
      <category term="pgp,gpg" scheme="https://talenhao.github.io/categories/pgp-gpg/"/>
    
    
      <category term="pgp,gpg" scheme="https://talenhao.github.io/tags/pgp-gpg/"/>
    
  </entry>
  
</feed>
