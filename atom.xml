<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天飞 学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://talenhao.github.io/"/>
  <updated>2019-12-23T05:36:22.000Z</updated>
  <id>https://talenhao.github.io/</id>
  
  <author>
    <name>天飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>microservice</title>
    <link href="https://talenhao.github.io/2019/12/23/microservice/"/>
    <id>https://talenhao.github.io/2019/12/23/microservice/</id>
    <published>2019-12-23T05:36:22.000Z</published>
    <updated>2019-12-23T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MicroService微服务"><a href="#MicroService微服务" class="headerlink" title="MicroService微服务"></a>MicroService微服务</h1><p><img src="../../../../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1.svg" alt="微服务"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MicroService微服务&quot;&gt;&lt;a href=&quot;#MicroService微服务&quot; class=&quot;headerlink&quot; title=&quot;MicroService微服务&quot;&gt;&lt;/a&gt;MicroService微服务&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../..
      
    
    </summary>
    
      <category term="service mesh" scheme="https://talenhao.github.io/categories/service-mesh/"/>
    
    
      <category term="service mesh" scheme="https://talenhao.github.io/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>Mysql DAL</title>
    <link href="https://talenhao.github.io/2019/12/23/Mysql-DAL/"/>
    <id>https://talenhao.github.io/2019/12/23/Mysql-DAL/</id>
    <published>2019-12-23T02:18:48.000Z</published>
    <updated>2019-12-23T02:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据访问层中间件（DAL）"><a href="#MySQL-数据访问层中间件（DAL）" class="headerlink" title="MySQL 数据访问层中间件（DAL）"></a>MySQL 数据访问层中间件（DAL）</h1><pre class="mermaid">graph TBclient-->altasclient-->mysql_routerclient-->mycataltas-->mastermysql_router-->mastermycat-->masteraltas-->slavemysql_router-->slavemycat-->slave</pre><pre class="mermaid">graph TBcobar-->mycat</pre><p>使用横向扩展，读写分离提升读性能</p><p>使用分库分表提升写性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-数据访问层中间件（DAL）&quot;&gt;&lt;a href=&quot;#MySQL-数据访问层中间件（DAL）&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据访问层中间件（DAL）&quot;&gt;&lt;/a&gt;MySQL 数据访问层中间件（DAL）&lt;/h1&gt;&lt;pre 
      
    
    </summary>
    
      <category term="uncategorized" scheme="https://talenhao.github.io/categories/uncategorized/"/>
    
    
      <category term="untags" scheme="https://talenhao.github.io/tags/untags/"/>
    
  </entry>
  
  <entry>
    <title>历年关键字</title>
    <link href="https://talenhao.github.io/2019/12/19/%E5%8E%86%E5%B9%B4%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://talenhao.github.io/2019/12/19/历年关键字/</id>
    <published>2019-12-19T07:31:52.000Z</published>
    <updated>2019-12-19T07:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><p><code>微服务</code></p><p><code>service mesh</code> <code>服务网格</code></p><p><code>serviceless</code></p><p><code>chaos enginering</code> <code>混沌工程</code></p><p><code>ant</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019&quot;&gt;&lt;a href=&quot;#2019&quot; class=&quot;headerlink&quot; title=&quot;2019&quot;&gt;&lt;/a&gt;2019&lt;/h1&gt;&lt;p&gt;&lt;code&gt;微服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;service mesh&lt;/code&gt; &lt;code&gt;服务网格&lt;/
      
    
    </summary>
    
      <category term="uncategorized" scheme="https://talenhao.github.io/categories/uncategorized/"/>
    
    
      <category term="untags" scheme="https://talenhao.github.io/tags/untags/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes学习笔记</title>
    <link href="https://talenhao.github.io/2019/11/27/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://talenhao.github.io/2019/11/27/kubernetes学习笔记/</id>
    <published>2019-11-27T11:26:34.000Z</published>
    <updated>2019-11-27T11:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><img src="../../../../images/docker-engine.png" alt="docker engine"></p><p>图片来自[<a href="https://www.qikqiak.com/k8s-book/docs/2.Docker%20%E7%AE%80%E4%BB%8B.html]" target="_blank" rel="noopener">https://www.qikqiak.com/k8s-book/docs/2.Docker%20%E7%AE%80%E4%BB%8B.html]</a>(<a href="https://www.qikqiak.com/k8s-book/docs/2.Docker" target="_blank" rel="noopener">https://www.qikqiak.com/k8s-book/docs/2.Docker</a> 简介.html)</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull [选项] [Docker Registry 地址[:端口]/]仓库名[:标签]</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t --rm 镜像:标签 /bin/bash</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run ubuntu:16.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span></span><br><span class="line">-d 后台运行</span><br><span class="line">docker commit修复运行的镜像读写层后提交</span><br></pre></td></tr></table></figure><p>列出镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/redis     latest              3c41ce05add9        5 months ago        95 MB</span><br></pre></td></tr></table></figure><p>当利用<code>docker run</code>来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层</p><ol><li>FROM 指定基础镜像<ol><li>官方高质量镜像</li><li>scratch 一个虚拟的镜像,表示空白</li></ol></li><li>RUN 运行命令(使用&amp;&amp;连接生成一层FS, 支持\ 换行 ,# 注释)<ol><li>shell:RUN &lt;命令&gt;</li><li>exec:RUN [“可执行文件”, “参数1”, “参数2”]</li></ol></li></ol><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>镜像构建上下文目录是相对engine来说的,不是本地的路径,必须改./开头.</p><p>使用-f可以指定任意名称的文件为dockerfile文件.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../images/docker-engine.png&quot; alt=&quot;d
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://talenhao.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://talenhao.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡后端检测</title>
    <link href="https://talenhao.github.io/2019/11/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%90%8E%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
    <id>https://talenhao.github.io/2019/11/13/负载均衡后端检测/</id>
    <published>2019-11-13T06:32:09.000Z</published>
    <updated>2019-11-13T06:32:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx后端检测"><a href="#nginx后端检测" class="headerlink" title="nginx后端检测"></a>nginx后端检测</h2><p>默认没有踢除功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nginx后端检测&quot;&gt;&lt;a href=&quot;#nginx后端检测&quot; class=&quot;headerlink&quot; title=&quot;nginx后端检测&quot;&gt;&lt;/a&gt;nginx后端检测&lt;/h2&gt;&lt;p&gt;默认没有踢除功能&lt;/p&gt;

      
    
    </summary>
    
      <category term="负载均衡" scheme="https://talenhao.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="lvs,nginx,haproxy" scheme="https://talenhao.github.io/tags/lvs-nginx-haproxy/"/>
    
  </entry>
  
  <entry>
    <title>linux资源管理</title>
    <link href="https://talenhao.github.io/2019/11/13/linux%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://talenhao.github.io/2019/11/13/linux资源管理/</id>
    <published>2019-11-13T04:04:10.000Z</published>
    <updated>2019-11-13T04:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>单进程-&gt;FD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用户单进程的最大文件数，用户登录时生效</span><br><span class="line">echo &apos;* soft nofile 1048576&apos; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &apos;* hard nofile 1048576&apos; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">ulimit -n 1048576 #用户单进程的最大文件描述符数 当前会话生效</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;单进程-&amp;gt;FD&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="linux" scheme="https://talenhao.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talenhao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>tcp/ip</title>
    <link href="https://talenhao.github.io/2019/11/13/tcp-ip/"/>
    <id>https://talenhao.github.io/2019/11/13/tcp-ip/</id>
    <published>2019-11-13T03:01:53.000Z</published>
    <updated>2019-11-13T03:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP协议源端口与目标端口分别占用2个字节(16个bit),共可存储2^16=65536个端口.去掉1024个系统保留端口,可用64512个端口.</p><p>一个客户端共可发起64512个TCP连接</p><p>服务端没有数量限制,取决于内存,CPU资源限制.服务端的TCP连接数为: socket fd(clientip:65412)*N.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端口号&quot;&gt;&lt;a href=&quot;#端口号&quot; class=&quot;headerlink&quot; title=&quot;端口号&quot;&gt;&lt;/a&gt;端口号&lt;/h2&gt;&lt;p&gt;TCP协议源端口与目标端口分别占用2个字节(16个bit),共可存储2^16=65536个端口.去掉1024个系统保留端口,可用64
      
    
    </summary>
    
      <category term="tcpip" scheme="https://talenhao.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip" scheme="https://talenhao.github.io/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://talenhao.github.io/2019/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://talenhao.github.io/2019/11/10/数据结构/</id>
    <published>2019-11-10T02:06:56.000Z</published>
    <updated>2019-11-10T02:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures 数据结构"></a>Data Structures 数据结构</h1><h2 id="heep-堆"><a href="#heep-堆" class="headerlink" title="heep(堆)"></a>heep(堆)</h2><p>堆(heap)又被为优先队列(priority queue),但并不是队列(按先后顺序).堆是按优先级dequeue(出队),enqueue(入队).</p><p>“堆”是实现调度器的理想数据结构。(Linux中可以使用nice命令来影响进程的优先级)</p><p>堆通常是一个可以被看做一棵完全二叉树(complete binary tree)的数组对象(二叉堆(binary heap)</p><p>堆顶的优先级高,堆的主要操作是插入和删除最小元素(元素值本身为优先级键值，小元素享有高优先级)。</p><ol><li><p>新加入的节点加入底部,与父节点比较优先级大小,比父节点小就交换.(percolate_up)</p></li><li><p>删除根节点后生成两个子树,重构堆(percolate_down).将lasted做为根连接子树</p></li></ol><p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p><p>堆的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个元素的序列&#123;k1,k2,ki,…,kn&#125;当且仅当满足下关系时，称之为堆。</span><br><span class="line">(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4...n/2)</span><br></pre></td></tr></table></figure><p>在程序中，堆用于动态分配和释放程序所使用的对象。在以下情况中调用堆操作：</p><ol><li><p>事先不知道程序所需对象的数量和大小。</p></li><li><p>对象太大，不适合使用堆栈分配器。</p></li></ol><p>堆使用运行期间分配给代码和堆栈以外的部分内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算公式</span><br><span class="line">parent(i) = floor((i - 1)/2)</span><br><span class="line">left(i)   = 2i + 1</span><br><span class="line">right(i)  = 2i + 2</span><br></pre></td></tr></table></figure><p>这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。事情比简单的去掉指针要复杂，但这就是交易：我们节约了空间，但是要进行更多计算。幸好这些计算很快并且只需要<strong>O(1)</strong>的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-Structures-数据结构&quot;&gt;&lt;a href=&quot;#Data-Structures-数据结构&quot; class=&quot;headerlink&quot; title=&quot;Data Structures 数据结构&quot;&gt;&lt;/a&gt;Data Structures 数据结构&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="dataStructures" scheme="https://talenhao.github.io/categories/dataStructures/"/>
    
    
      <category term="dataStructures" scheme="https://talenhao.github.io/tags/dataStructures/"/>
    
  </entry>
  
  <entry>
    <title>react</title>
    <link href="https://talenhao.github.io/2019/11/05/react/"/>
    <id>https://talenhao.github.io/2019/11/05/react/</id>
    <published>2019-11-05T02:51:13.000Z</published>
    <updated>2019-11-05T02:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-遍历"><a href="#react-遍历" class="headerlink" title="react 遍历"></a>react 遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.data.map(</span><br><span class="line">  (item, index)=&gt;&#123;</span><br><span class="line">    item.key = index;</span><br><span class="line">    return item;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="antd-table"><a href="#antd-table" class="headerlink" title="antd table"></a>antd table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const columns</span><br><span class="line">const dataSource</span><br><span class="line">const rowSelection</span><br></pre></td></tr></table></figure><h2 id="CROS"><a href="#CROS" class="headerlink" title="CROS"></a>CROS</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at 'http://127.0.0.1:8000/api/imooc/order/' from origin 'http://127.0.0.1:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://127.0.0.1:3000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pip install django djangorestframework django-cors-headers</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'corsheaders',</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">...</span><br><span class="line">    'corsheaders.middleware.CorsMiddleware'</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL=True</span><br><span class="line">或</span><br><span class="line">CORS_ORIGIN_WHITELIST = [</span><br><span class="line">    'google.com',</span><br><span class="line">    'hostname.example.com',</span><br><span class="line">    'localhost:8000',</span><br><span class="line">    '127.0.0.1:9000'</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="index-js-1375-Warning-Failed-prop-type-Invalid-prop-id-of-type-array-supplied-to-Select-expected-string"><a href="#index-js-1375-Warning-Failed-prop-type-Invalid-prop-id-of-type-array-supplied-to-Select-expected-string" class="headerlink" title="index.js:1375 Warning: Failed prop type: Invalid prop id of type array supplied to Select, expected string."></a>index.js:1375 Warning: Failed prop type: Invalid prop <code>id</code> of type <code>array</code> supplied to <code>Select</code>, expected <code>string</code>.</h2><h3 id="expected-to-return-a-value-in-arrow-function-array-callback-return"><a href="#expected-to-return-a-value-in-arrow-function-array-callback-return" class="headerlink" title="expected to return a value in arrow function array-callback-return"></a>expected to return a value in arrow function array-callback-return</h3><p>A <code>map()</code> creates an array, so a <code>return</code> is expected for all code paths (if/elses).</p><p>If you don’t want an array or to return data, use <code>forEach</code> instead.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-遍历&quot;&gt;&lt;a href=&quot;#react-遍历&quot; class=&quot;headerlink&quot; title=&quot;react 遍历&quot;&gt;&lt;/a&gt;react 遍历&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="front-end" scheme="https://talenhao.github.io/categories/front-end/"/>
    
    
      <category term="react" scheme="https://talenhao.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel</title>
    <link href="https://talenhao.github.io/2019/11/01/Linux-kernel/"/>
    <id>https://talenhao.github.io/2019/11/01/Linux-kernel/</id>
    <published>2019-11-01T10:05:31.000Z</published>
    <updated>2019-11-01T10:05:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li>文件</li><li>目录</li><li>链接</li><li>块设备</li><li>字符设备</li><li>管道</li><li>套接字</li></ol><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>inode惟一索引</p><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Fri Nov 01 talen@tp hexo.blog]$ <span class="built_in">stat</span> yarn.lock</span><br><span class="line">File: yarn.lock</span><br><span class="line">Size: 97141           Blocks: 192        IO Block: 4096   regular file</span><br><span class="line">Device: 803h/2051d      Inode: 42116468    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/   talen)   Gid: (  985/   users)</span><br><span class="line">Access: 2019-09-16 17:39:57.848034466 +0800</span><br><span class="line">Modify: 2019-07-24 20:51:25.073555443 +0800</span><br><span class="line">Change: 2019-07-24 20:51:25.073555443 +0800</span><br><span class="line">Birth: 2019-07-24 20:51:25.073555443 +0800</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><h5 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h5><ol><li>owner</li><li>group</li><li>other</li></ol><h5 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h5><ol><li>读r</li><li>写w</li><li>执行x</li><li>suid : 进程执行时获取文件拥有者uid的权限</li><li>sgid: 进行执行时获取文件拥有者用户组gid的权限 </li><li>sticky: 向kernel发送一个请求,进程结束后保留在内存中.</li></ol><h4 id="文件内核系统调用"><a href="#文件内核系统调用" class="headerlink" title="文件内核系统调用"></a>文件内核系统调用</h4><p>创建一个文件对象,包含文件指针(使用lseek()改变文件指针位置)</p><ol><li>打开<ol><li>fd = open(path, flag, mode) # 参数分别对应 路径,操作,权限</li></ol></li><li>创建</li><li>访问<ol><li>顺序<ol><li>设备文件</li><li>管道</li></ol></li><li>随机<ol><li>普通文件</li></ol></li><li>read() and write()<ol><li>nread = read(fd, buf, count)</li><li>nwrite = write(fd, buf, count)</li></ol></li><li>close<ol><li>res = close(fd)</li></ol></li></ol></li><li>文件指针<ol><li>newoffset=lseek(fd, offset, whence)</li></ol></li><li>删除,生命名文件不需要打开<ol><li>res = rename(oldpath, newpath)</li><li>res = unlink(pathname)</li></ol></li></ol><h3 id="文件描述符FD"><a href="#文件描述符FD" class="headerlink" title="文件描述符FD"></a>文件描述符FD</h3><p>是进程-&gt;文件描述符FD-&gt;文件对象</p><ol><li>同一进程可有多个FD</li><li>多个进程可以同时操作一个文件,系统不提供同步</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h3><p>单处理器,同一时间只有一个进程在运行,用户态的进程调用系统调用后切换到内核态</p><ol><li>用户态<ol><li>|用户态进程调用系统调用切换到内核态</li><li>进程CPU发出异常信号,内核代表产生异常的进程处理异常</li><li>外围设备发出中断请求</li><li>内核进程被执行</li></ol></li><li>内核态</li></ol><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>进程描述符</p><p>进程暂停时,几个相关的处理器寄存器保存在进程描述符中</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>system V ipc</p><ol><li>信号量</li><li>消息队列 POSIX消息队列 </li><li>共享内存</li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>fork() 父创建新进程<ol><li>wait4()等待子进程退出,返回子进程pid</li><li>init特殊进程管理所有子进程</li></ol></li><li>_exit() 退出进程</li><li>exec() 装入一个新程序</li></ol><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间.</p><p>可用于进程间共享数据</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>硬件-&gt;虚拟内存-&gt;进程</p><h3 id="随机访问存储器RAM"><a href="#随机访问存储器RAM" class="headerlink" title="随机访问存储器RAM"></a>随机访问存储器RAM</h3><p>内核映像+虚拟内存</p><p>平衡每个内存请求,并在达到阀值时调用页框回收(page frame reclaiming)算法释放其它内存</p><ol><li>内核映像:<ol><li>内核代码</li><li>内核静态数据结构</li></ol></li><li>虚拟内存:<ol><li>内核缓冲区,描述符,动态数据结构</li><li>进程内存请求</li><li>高速缓存</li></ol></li></ol><h3 id="内核内存分配器KMA"><a href="#内核内存分配器KMA" class="headerlink" title="内核内存分配器KMA"></a>内核内存分配器KMA</h3><p>虚拟内存系统一个主要问题是内存碎片</p><ol><li>快</li><li>利用率高,浪费少,碎片少</li><li>与其它内存管理子系统配合</li></ol><p><code>linux在众多算法中选择了solaris的slab分配算法</code></p><h3 id="进程的虚拟地址空间处理"><a href="#进程的虚拟地址空间处理" class="headerlink" title="进程的虚拟地址空间处理"></a>进程的虚拟地址空间处理</h3><p>内核使用一组内存区描述符描述虚拟地址空间.进程通过exec()系统调用开始执行.</p><p>描述符区:</p><ol><li>代码区</li><li>初始化数据</li><li>未初始化数据</li><li>程序栈</li><li>共享库代码及数据</li><li>堆(动态内存)</li></ol><p>请求调页,写时复制</p><p>高速缓存 sync()将脏数据写回磁盘</p><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>kernel-&gt;驱动-&gt;I/O设备</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;块设备&lt;/li&gt;
&lt;li&gt;字符设备&lt;/li&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;套接字&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h3&gt;&lt;p&gt;inode惟一索引&lt;/p&gt;
&lt;h4 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Fri Nov 01 talen@tp hexo.blog]$ &lt;span class=&quot;built_in&quot;&gt;stat&lt;/span&gt; yarn.lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File: yarn.lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Size: 97141           Blocks: 192        IO Block: 4096   regular file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Device: 803h/2051d      Inode: 42116468    Links: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access: (0644/-rw-r--r--)  Uid: ( 1000/   talen)   Gid: (  985/   users)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Access: 2019-09-16 17:39:57.848034466 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Modify: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Change: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Birth: 2019-07-24 20:51:25.073555443 +0800&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="https://talenhao.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talenhao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>javascript 学习</title>
    <link href="https://talenhao.github.io/2019/09/28/javascript-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://talenhao.github.io/2019/09/28/javascript-学习/</id>
    <published>2019-09-28T13:24:14.000Z</published>
    <updated>2019-09-28T13:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>html是结构,CSS是表示,js是动态</p><pre class="mermaid">graph TBES5ES6node(node.js ES服务端运行环境)ES6-->babel(babel转码器)babel-->ES5less-->cssjsonp[jsonp可以跨域]-->apiaxios[axios不能跨域]-->api</pre><p>一个变量,多个数组</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量要先声明再赋值</strong></p><p>变量名规范:</p><ol><li>必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字</li><li><strong>变量名区分大小写</strong></li><li>不允许使用JavaScript关键字和保留字做变量名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名,变量<span class="number">2</span>,变量n; <span class="comment">//变量需要声明</span></span><br><span class="line"><span class="keyword">var</span> mychar;</span><br><span class="line">mychar=<span class="string">"javascript"</span>;</span><br><span class="line"><span class="keyword">var</span> mynum = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>输出变量,字符串可以使用+号串连</p><p>ES6增加let代码块作用域变量</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>创建数组语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myarray=new Array(num); //num是数组初始长度,可为空, 可扩展</span><br></pre></td></tr></table></figure><p>数组赋值:</p><p>JS的数组中添加元素只需要使用未使用的索引即可.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//定义数组</span></span><br><span class="line"> myarr[<span class="number">0</span>]=<span class="number">80</span>; </span><br><span class="line"> myarr[<span class="number">1</span>]=<span class="number">60</span>;</span><br><span class="line"> myarr[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="keyword">var</span> myarray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>);<span class="comment">//创建数组同时赋值</span></span><br><span class="line"><span class="keyword">var</span> myarray = [<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>];<span class="comment">//直接输入一个数组（称 “字面量数组”）</span></span><br></pre></td></tr></table></figure><p>数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarray.length; <span class="comment">//获得数组myarray的长度</span></span><br></pre></td></tr></table></figure><p>数组的维度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一维数组的表示: myarray[ ]</span><br><span class="line">二维数组的表示: myarray[ ][ ]</span><br><span class="line"><span class="keyword">var</span> Myarr = [[<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>]]</span><br><span class="line">myarr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">5</span>; <span class="comment">//将5的值传入到数组中，覆盖原有值。说明: myarr[0][1] ,0 表示表的行，1表示表的列。</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>算术操作符(+、-、*、/等)，比较操作符(&lt;、&gt;、&gt;=、&lt;=等)，逻辑操作符(&amp;&amp;、||、！)</p><p>自加一<code>“++”</code>；自减一<code>“--”</code></p><p><strong>操作符之间的优先级（高到低）:</strong></p><p>算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</p><h2 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)</span><br><span class="line">&#123; 条件<span class="number">1</span>成立时执行的代码&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>(条件<span class="number">2</span>)</span><br><span class="line">&#123; 条件<span class="number">2</span>成立时执行的代码&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">if</span>(条件n)</span><br><span class="line">&#123; 条件n成立时执行的代码&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; 条件<span class="number">1</span>、<span class="number">2</span>至n不成立时执行的代码&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有很多种选项的时候，switch比if else使用更方便。</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>值<span class="number">1</span>:</span><br><span class="line">  执行代码块 <span class="number">1</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>值<span class="number">2</span>:</span><br><span class="line">  执行代码块 <span class="number">2</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span>值n:</span><br><span class="line">  执行代码块 n</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  与 <span class="keyword">case</span>值<span class="number">1</span> 、 <span class="keyword">case</span>值<span class="number">2.</span>..case值n 不同时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化变量;循环条件;循环迭代)</span><br><span class="line">&#123;     </span><br><span class="line">    循环语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断条件)</span><br><span class="line">&#123;</span><br><span class="line">    循环语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="comment">//先执行一次再循环</span></span><br><span class="line">&#123;</span><br><span class="line">    循环语句</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">while</span>(判断条件)</span><br></pre></td></tr></table></figure><p>break语句退出当前循环，直接执行后面的代码</p><p>continue的作用是仅仅跳过本次循环</p><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>函数定义后需要调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure><h2 id="JavaScript-警告（alert-消息对话框）"><a href="#JavaScript-警告（alert-消息对话框）" class="headerlink" title="JavaScript-警告（alert 消息对话框）"></a>JavaScript-警告（alert 消息对话框）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><h2 id="JavaScript-确认（confirm-消息对话框）"><a href="#JavaScript-确认（confirm-消息对话框）" class="headerlink" title="JavaScript-确认（confirm 消息对话框）"></a>JavaScript-确认（confirm 消息对话框）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: Boolean值</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击&quot;确定&quot;按钮时，返回true</span><br><span class="line">当用户点击&quot;取消&quot;按钮时，返回false</span><br></pre></td></tr></table></figure><h2 id="JavaScript-提问（prompt-消息对话框）"><a href="#JavaScript-提问（prompt-消息对话框）" class="headerlink" title="JavaScript-提问（prompt 消息对话框）"></a>JavaScript-提问（prompt 消息对话框）</h2><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line">2. 点击取消按钮，将返回null</span><br></pre></td></tr></table></figure><h2 id="JavaScript-打开新窗口（window-open）"><a href="#JavaScript-打开新窗口（window-open）" class="headerlink" title="JavaScript-打开新窗口（window.open）"></a>JavaScript-打开新窗口（window.open）</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    1.该名称由字母、数字和下划线字符组成。</span><br><span class="line">    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">   4.name 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><img src="../../../../images/52e3677900013d6a05020261.jpg" alt="img"></strong></p><h2 id="JavaScript-关闭窗口（window-close）"><a href="#JavaScript-关闭窗口（window-close）" class="headerlink" title="JavaScript-关闭窗口（window.close）"></a>JavaScript-关闭窗口（window.close）</h2><p>close()关闭窗口</p><p><strong>用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close();   //关闭本窗口</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   //关闭指定的窗口</span><br></pre></td></tr></table></figure><h2 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h2><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><img src="../../../../images/52e4bd0f0001dd8d04830279.jpg" alt="img"></p><p><strong>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</strong></p><p>&lt;元素标签 属性&gt;文本&lt;元素&gt;</p><p>为元素标签配置惟一ID属性,通过ID获取元素</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(“id”)</span><br></pre></td></tr></table></figure><p><strong>结果:null</strong>或[<strong>object HTMLParagraphElement]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object.innerHTML; //获取/修改元素的内容</span><br><span class="line"></span><br><span class="line">Object.style.property=new style; //修改元素的CSS样式</span><br><span class="line">&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   var mychar = document.getElementById(&quot;pcon&quot;);</span><br><span class="line">   mychar.style.color=&quot;red&quot;;</span><br><span class="line">   mychar.style.fontSize=&quot;20&quot;;</span><br><span class="line">   mychar.style.backgroundColor =&quot;blue&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Object.style.display = none/block；//显示或隐藏对象</span><br><span class="line"></span><br><span class="line">object.className = classname; //配置对象类名</span><br></pre></td></tr></table></figure><p><img src="../../../../images/52e4d4240001dd6c04850229.jpg" alt="img"></p><p>整理链接:<a href="https://www.imooc.com/code/468" target="_blank" rel="noopener">https://www.imooc.com/code/468</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;html是结构,CSS是表示,js是动态&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph TB
ES5
ES6
node(node.js ES服务端运行环境)
ES6--&gt;babel(babel转码器)
babel--&gt;ES5
less--&gt;css
jsonp
      
    
    </summary>
    
      <category term="front-end" scheme="https://talenhao.github.io/categories/front-end/"/>
    
    
      <category term="front-end" scheme="https://talenhao.github.io/tags/front-end/"/>
    
      <category term="javascript" scheme="https://talenhao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>英语历史</title>
    <link href="https://talenhao.github.io/2019/09/19/%E8%8B%B1%E8%AF%AD%E5%8E%86%E5%8F%B2/"/>
    <id>https://talenhao.github.io/2019/09/19/英语历史/</id>
    <published>2019-09-19T09:11:18.000Z</published>
    <updated>2019-09-19T09:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语历史"><a href="#英语历史" class="headerlink" title="英语历史"></a>英语历史</h1><pre class="mermaid">graph TB腓尼基字母-->希腊字母希腊字母-->拉丁字母拉丁字母-->英文字母</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;英语历史&quot;&gt;&lt;a href=&quot;#英语历史&quot; class=&quot;headerlink&quot; title=&quot;英语历史&quot;&gt;&lt;/a&gt;英语历史&lt;/h1&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB
腓尼基字母--&gt;希腊字母
希腊字母--&gt;拉丁字母
拉丁字母--&gt;英文字
      
    
    </summary>
    
      <category term="english" scheme="https://talenhao.github.io/categories/english/"/>
    
    
      <category term="english" scheme="https://talenhao.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>浏览器攻击</title>
    <link href="https://talenhao.github.io/2019/09/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%BB%E5%87%BB/"/>
    <id>https://talenhao.github.io/2019/09/11/浏览器攻击/</id>
    <published>2019-09-11T01:51:49.000Z</published>
    <updated>2019-09-11T01:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器跨域"><a href="#浏览器跨域" class="headerlink" title="浏览器跨域"></a>浏览器跨域</h2><p>JavaScript出于<em>安全</em>方面的考虑做的<em>同源</em>策略的<em>限制</em>，不允许<em>跨域</em>访问其他资源。跨域请求成功后，浏览器会拦截服务器端返回的结果</p><p>同源:<code>域名、协议、端口均相同。举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略）</code></p><a id="more"></a><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>攻击者指挥用户攻击目标网站</p><pre class="mermaid">graph LRuser-->|1,username&password|target(目标网站)target-->|2,OK&set cookie|useruser-.->|3,目标cookie存在,访问攻击者站点|tacker[攻击者站点]tacker-.->|4,让用户请求目标网站执行特定操作|useruser-.->|5,利用自己的权限做攻击操作|target</pre><pre class="mermaid">sequenceDiagramparticipant attacker as 攻击者站点participant user as 用户participant target as 目标站点user->>+target:1,request,username&passwordtarget-->>user:2,response,set-cookieuser->>+attacker:3,request,请求攻击者站点attacker-->>-user:4,response,指挥用户访问目标站点user->>-target:5,request,利用自己的权限发起攻击操作</pre><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>伪装用户自己发起攻击</p><pre class="mermaid">sequenceDiagramparticipant attacker as 攻击者站点participant user as 用户participant target as 目标站点attacker-->>user:1,request,发送含有攻击代码的目标站点链接user->>+target:2,request,携带攻击代码,请求目标站点target-->>user:3,response,目标站点执行后返回用户数据user->>attacker:4,request,在用户不知情时将cookie,session发送给攻击者attacker->>-target:5,request,伪装用户访问目标站点</pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器跨域&quot;&gt;&lt;a href=&quot;#浏览器跨域&quot; class=&quot;headerlink&quot; title=&quot;浏览器跨域&quot;&gt;&lt;/a&gt;浏览器跨域&lt;/h2&gt;&lt;p&gt;JavaScript出于&lt;em&gt;安全&lt;/em&gt;方面的考虑做的&lt;em&gt;同源&lt;/em&gt;策略的&lt;em&gt;限制&lt;/em&gt;，不允许&lt;em&gt;跨域&lt;/em&gt;访问其他资源。跨域请求成功后，浏览器会拦截服务器端返回的结果&lt;/p&gt;
&lt;p&gt;同源:&lt;code&gt;域名、协议、端口均相同。举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略）&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="safe" scheme="https://talenhao.github.io/categories/safe/"/>
    
    
      <category term="safe" scheme="https://talenhao.github.io/tags/safe/"/>
    
  </entry>
  
  <entry>
    <title>监控系统预测和异常判断</title>
    <link href="https://talenhao.github.io/2019/09/06/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E9%A2%84%E6%B5%8B%E5%92%8C%E5%BC%82%E5%B8%B8%E5%88%A4%E6%96%AD/"/>
    <id>https://talenhao.github.io/2019/09/06/监控系统预测和异常判断/</id>
    <published>2019-09-06T07:08:23.000Z</published>
    <updated>2019-09-06T07:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控系统预测和异常判断"><a href="#监控系统预测和异常判断" class="headerlink" title="监控系统预测和异常判断"></a>监控系统预测和异常判断</h1><p>基于算法的 IT 运维平台(Algorithmic IT operations platforms)</p><ol><li>机器学习</li><li>数学统计<ol><li>方差分析可以用来判断几组观察到的数据或者处理的结果是否存在显著差异。</li><li>在方差分析中，我们把要考察其均值是否存在显著差异的指标变量称为响应变量，对响应变量取值有影响的其他变量称为因素。例如，信用卡消费水平和治疗效果为响应变量，地区和药品则为因素。在方差分析中，因素的取值应为离散型的，其不同的取值称为水平。例如，每一个具体地区或者每一种药品都对应着一个水平。根据因素的个数，方差分析可以分为单因素方差分析和多因素方差分析</li><li><strong>正态分布像一只倒扣的钟。两头低，中间高，左右对称。大部分数据集中在平均值，小部分在两端。</strong></li></ol></li></ol><h2 id="异常判断"><a href="#异常判断" class="headerlink" title="异常判断"></a>异常判断</h2><p>指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。</p><a id="more"></a><h3 id="异常算法"><a href="#异常算法" class="headerlink" title="异常算法"></a>异常算法</h3><p>skyline 一共提供了 7 个异常检测算法，如果有 5 个以上认为是异常，那么 skyline就认为这个序列异常了.</p><p>异常检测算法实际写在了 <code>src/analyzer/algorithms.py</code></p><ol><li>first_hour_average、</li><li>simple_stddev_from_moving_average、</li><li>stddev_from_moving_average、</li><li>mean_subtraction_cumulation、</li><li>least_squares</li><li>histogram_bins、</li><li>grubbs、</li><li>median_absolute_deviation、</li><li>Kolmogorov-Smirnov_test</li></ol><h3 id="first-hour-average"><a href="#first-hour-average" class="headerlink" title="first_hour_average"></a>first_hour_average</h3><p>这是最简单的。先求本周期内最前面的第一个小时的平均值和标准差，然后和最新的三个值的平均值(tail_avg()，这是后面多数算法都通用的做法)做比较。如果 tail_avg 和 第一小时平均值的差距大于 3 倍的标准差，那么认定为异常。</p><h3 id="simple-stddev-from-moving-average"><a href="#simple-stddev-from-moving-average" class="headerlink" title="simple_stddev_from_moving_average"></a>simple_stddev_from_moving_average</h3><p>把上面算法的范围扩大化，求的是整个周期内全部数据的平均值和标准差。</p><h3 id="stddev-from-moving-average"><a href="#stddev-from-moving-average" class="headerlink" title="stddev_from_moving_average"></a>stddev_from_moving_average</h3><p>在上面算法的基础上，采用指数加权移动平均值。对周期内采点数量较少的情况更好一些。</p><h3 id="mean-subtraction-cumulation"><a href="#mean-subtraction-cumulation" class="headerlink" title="mean_subtraction_cumulation"></a>mean_subtraction_cumulation</h3><p>做法是这样的：</p><ol><li>排除最后一个值；</li><li>求剩余序列的平均值；</li><li>全序列减去上面这个平均值；</li><li>求剩余序列的标准差；</li><li>判断全序列最后一个值是否大于 3 倍的标准差</li></ol><p>在代码中本来还计算了一次序列的指数加权移动平均值，但是算完了却没用，感觉怪怪的。</p><h3 id="least-squares"><a href="#least-squares" class="headerlink" title="least_squares"></a>least_squares</h3><p>采用最小二乘法拟近时间序列，然后用实际值减去拟近值得到新序列。然后判断新序列的最后三个值的平均值是否大于 3 倍的新序列标准差。</p><p>所谓最小二乘法，简单说就是对一个 [x, y] 序列，会有一对常数 [m, c]，让 Y = mx + c 等式中的 Y 和 y 在全序列上最接近。</p><h3 id="histogram-bins"><a href="#histogram-bins" class="headerlink" title="histogram_bins"></a>histogram_bins</h3><p>将整个周期序列的数据按照直方图统计法归入 15 个直方中，然后看最后三个值的平均值属于这 15 个直方的具体哪个。如果这个直方中包含的数据小于 20 个，判断为异常。</p><p>从算法中可以知道，如果周期内数据量不够，很容易被判断为异常的。</p><h3 id="grubbs"><a href="#grubbs" class="headerlink" title="grubbs"></a>grubbs</h3><p>将整个周期序列的数据按照格拉布斯法求异常值。</p><p>标准的格拉布斯法是这样的：</p><ol><li>从小到大排序；</li><li>求序列的平均值和标准差；</li><li>计算最小值和最大值与平均值的差距，更大的那个为可疑值；</li><li>可疑值减去平均值，再除以标准差，如果大于格拉布斯临界值，那么就是异常值；</li><li>排除异常值，对剩余序列循环做 1-5 步骤。</li></ol><p>这里只用判断时间序列的最后是否异常，所以直接将最后三个值的平均值作为可疑值判断是否异常即可。</p><p><strong>2013 年 07 月 23 日更新</strong></p><p>新增了一个异常算法，现在有 8 个了，要通过 6 个才算真异常。</p><p>新增的是”绝对中值偏差法”</p><h3 id="median-absolute-deviation"><a href="#median-absolute-deviation" class="headerlink" title="median_absolute_deviation"></a>median_absolute_deviation</h3><p>具体实现是：序列的最后一个值，比该序列的绝对中值大 6 倍以上，即判断为异常。</p><p>注意这里是中值，不是平均值。</p><p><strong>2013 年 08 月 14 日更新</strong></p><p>新增一个异常算法，现在有 9 个了。</p><p>新增的是”柯尔莫诺夫-斯米尔诺夫检验法”</p><h3 id="Kolmogorov-Smirnov-test"><a href="#Kolmogorov-Smirnov-test" class="headerlink" title="Kolmogorov-Smirnov_test"></a>Kolmogorov-Smirnov_test</h3><p>具体实现是：计算序列内最近十分钟的数值的ks测试分布，然后计算序列中最近一个小时前到十分钟前这 50 分钟的数值的ks测试分布；如果两个分布相差较大，即判断为异常。</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><h3 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h3><p>时序存储</p><p> rrdtool 和 graphite</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;监控系统预测和异常判断&quot;&gt;&lt;a href=&quot;#监控系统预测和异常判断&quot; class=&quot;headerlink&quot; title=&quot;监控系统预测和异常判断&quot;&gt;&lt;/a&gt;监控系统预测和异常判断&lt;/h1&gt;&lt;p&gt;基于算法的 IT 运维平台(Algorithmic IT operations platforms)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;数学统计&lt;ol&gt;
&lt;li&gt;方差分析可以用来判断几组观察到的数据或者处理的结果是否存在显著差异。&lt;/li&gt;
&lt;li&gt;在方差分析中，我们把要考察其均值是否存在显著差异的指标变量称为响应变量，对响应变量取值有影响的其他变量称为因素。例如，信用卡消费水平和治疗效果为响应变量，地区和药品则为因素。在方差分析中，因素的取值应为离散型的，其不同的取值称为水平。例如，每一个具体地区或者每一种药品都对应着一个水平。根据因素的个数，方差分析可以分为单因素方差分析和多因素方差分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正态分布像一只倒扣的钟。两头低，中间高，左右对称。大部分数据集中在平均值，小部分在两端。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;异常判断&quot;&gt;&lt;a href=&quot;#异常判断&quot; class=&quot;headerlink&quot; title=&quot;异常判断&quot;&gt;&lt;/a&gt;异常判断&lt;/h2&gt;&lt;p&gt;指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。&lt;/p&gt;
    
    </summary>
    
      <category term="monitor" scheme="https://talenhao.github.io/categories/monitor/"/>
    
    
      <category term="monitor,alert" scheme="https://talenhao.github.io/tags/monitor-alert/"/>
    
  </entry>
  
  <entry>
    <title>keepalived</title>
    <link href="https://talenhao.github.io/2019/09/04/keepalived/"/>
    <id>https://talenhao.github.io/2019/09/04/keepalived/</id>
    <published>2019-09-04T03:01:41.000Z</published>
    <updated>2019-09-04T03:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h1><pre class="mermaid">graph TBkeepalived_module-->corekeepalived_module-->checkkeepalived_module-->vrrp</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;keepalived&quot;&gt;&lt;a href=&quot;#keepalived&quot; class=&quot;headerlink&quot; title=&quot;keepalived&quot;&gt;&lt;/a&gt;keepalived&lt;/h1&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB
keepalived_
      
    
    </summary>
    
      <category term="lb" scheme="https://talenhao.github.io/categories/lb/"/>
    
    
      <category term="lb,keepalived" scheme="https://talenhao.github.io/tags/lb-keepalived/"/>
    
  </entry>
  
  <entry>
    <title>VRRP协议</title>
    <link href="https://talenhao.github.io/2019/09/04/VRRP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://talenhao.github.io/2019/09/04/VRRP协议/</id>
    <published>2019-09-04T01:42:41.000Z</published>
    <updated>2019-09-04T01:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VRRP协议"><a href="#VRRP协议" class="headerlink" title="VRRP协议"></a>VRRP协议</h1><p>Skew time(秒)=(256－Backup路由器的优先级)/256</p><p>Master_Down_Interval(秒)=(3×VRRP报文的发送时间间隔)+Skew time</p><pre class="mermaid">sequenceDiagramparticipant up as 上层路由器participant m as master routerNote left of m: 00-00-5E-00-01-{VRID} & VIP & 优先级participant s as backup routerloop intervalm-->>s: vrrp 通告报文 I'm alive!endloop intervals-->>m:BFD检测快速切换endloop intervalm-->>up:NQA检测调整自身优先级end</pre><a id="more"></a><pre class="mermaid">graph TBvr((virtual_router))-->rr0((real_router_0))vr-->rr1((real_router_1))vr-->rr2((real_router_2))</pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;VRRP协议&quot;&gt;&lt;a href=&quot;#VRRP协议&quot; class=&quot;headerlink&quot; title=&quot;VRRP协议&quot;&gt;&lt;/a&gt;VRRP协议&lt;/h1&gt;&lt;p&gt;Skew time(秒)=(256－Backup路由器的优先级)/256&lt;/p&gt;
&lt;p&gt;Master_Down_Interval(秒)=(3×VRRP报文的发送时间间隔)+Skew time&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;sequenceDiagram
participant up as 上层路由器
participant m as master router
Note left of m: 00-00-5E-00-01-{VRID} &amp; VIP &amp; 优先级
participant s as backup router

loop interval
m--&gt;&gt;s: vrrp 通告报文 I&#39;m alive!
end
loop interval
s--&gt;&gt;m:BFD检测快速切换
end
loop interval
m--&gt;&gt;up:NQA检测调整自身优先级
end&lt;/pre&gt;
    
    </summary>
    
      <category term="network" scheme="https://talenhao.github.io/categories/network/"/>
    
    
      <category term="network,vrrp" scheme="https://talenhao.github.io/tags/network-vrrp/"/>
    
  </entry>
  
  <entry>
    <title>pgp加密</title>
    <link href="https://talenhao.github.io/2019/09/01/pgp%E5%8A%A0%E5%AF%86/"/>
    <id>https://talenhao.github.io/2019/09/01/pgp加密/</id>
    <published>2019-09-01T04:28:35.000Z</published>
    <updated>2019-09-01T04:28:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pgp加密"><a href="#pgp加密" class="headerlink" title="pgp加密"></a>pgp加密</h1><p>GnuPG 是一个用来进行非对称加密(PGP)的免费软件，简称GPG</p><p>PGP是一个基于RSA公匙加密体系的邮件加密软件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pgp加密&quot;&gt;&lt;a href=&quot;#pgp加密&quot; class=&quot;headerlink&quot; title=&quot;pgp加密&quot;&gt;&lt;/a&gt;pgp加密&lt;/h1&gt;&lt;p&gt;GnuPG 是一个用来进行非对称加密(PGP)的免费软件，简称GPG&lt;/p&gt;
&lt;p&gt;PGP是一个基于RSA公匙加密体
      
    
    </summary>
    
      <category term="pgp,gpg" scheme="https://talenhao.github.io/categories/pgp-gpg/"/>
    
    
      <category term="pgp,gpg" scheme="https://talenhao.github.io/tags/pgp-gpg/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch_dsl使用</title>
    <link href="https://talenhao.github.io/2019/08/30/elasticsearch-dsl%E4%BD%BF%E7%94%A8/"/>
    <id>https://talenhao.github.io/2019/08/30/elasticsearch-dsl使用/</id>
    <published>2019-08-30T07:59:40.000Z</published>
    <updated>2019-08-30T07:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;size&quot;: 0,</span><br><span class="line">&quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;by_grp&quot; : &#123;</span><br><span class="line">        &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;grpId&quot;,</span><br><span class="line">            &quot;size&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;twitter_count&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;twitter.followers&quot;,</span><br><span class="line">                    &quot;ranges&quot;: [</span><br><span class="line">                        &#123; &quot;to&quot; : 501&#125;,</span><br><span class="line">                        &#123; &quot;from&quot; : 501, &quot;to&quot; : 1001&#125;,</span><br><span class="line">                        &#123; &quot;from&quot; : 1001, &quot;to&quot; : 5001&#125;,</span><br><span class="line">                        &#123; &quot;from&quot; : 5001&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;aggs&quot; : &#123;</span><br><span class="line">                    &quot;email_addy&quot;: &#123;</span><br><span class="line">                        &quot;terms&quot; : &#123;</span><br><span class="line">                            &quot;field&quot;: &quot;email.value&quot;,</span><br><span class="line">                            &quot;size&quot;: 0</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s.aggs.bucket(<span class="string">'by_grp'</span>, <span class="string">'terms'</span>, field=<span class="string">'grpId'</span>, size=<span class="number">0</span>) \</span><br><span class="line">.bucket(<span class="string">'twitter_count'</span>, <span class="string">'range'</span>, field=<span class="string">'twitter.followers'</span>,</span><br><span class="line">    ranges=[</span><br><span class="line">        &#123;<span class="string">'to'</span>: <span class="number">5001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'from'</span>: <span class="number">5001</span>, <span class="string">'to'</span>: <span class="number">10001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'from'</span>: <span class="number">10001</span>, <span class="string">'to'</span>: <span class="number">50001</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'from'</span>: <span class="number">50001</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">) \</span><br><span class="line">.bucket(<span class="string">'email_addy'</span>, <span class="string">'terms'</span>, field=<span class="string">'email.value'</span>, size=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="elasticsearch" scheme="https://talenhao.github.io/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://talenhao.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>消息队列</title>
    <link href="https://talenhao.github.io/2019/08/28/mq/"/>
    <id>https://talenhao.github.io/2019/08/28/mq/</id>
    <published>2019-08-28T02:00:41.000Z</published>
    <updated>2019-08-28T02:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息传输模型"><a href="#消息传输模型" class="headerlink" title="消息传输模型"></a>消息传输模型</h2><ol><li>[1to1]点对点(point-to-point)</li><li>[MtoM]生产消费(produce-queue-consumer)</li><li>[1toM]发布订阅(PUBSUB)<ol><li>广播(subscriber拿相同的消息)</li><li>request-reply应答</li><li>队列分发(每个subscriber拿到的不一样)</li></ol></li></ol><h2 id="考量标准"><a href="#考量标准" class="headerlink" title="考量标准"></a>考量标准</h2><p>三个维度上去考量，吞吐量、时延、可靠性</p><ol><li>nats本身没有实现存储,可靠性要客户端服务端实现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息传输模型&quot;&gt;&lt;a href=&quot;#消息传输模型&quot; class=&quot;headerlink&quot; title=&quot;消息传输模型&quot;&gt;&lt;/a&gt;消息传输模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;[1to1]点对点(point-to-point)&lt;/li&gt;
&lt;li&gt;[MtoM]生产消费(pr
      
    
    </summary>
    
      <category term="mq" scheme="https://talenhao.github.io/categories/mq/"/>
    
    
      <category term="mq" scheme="https://talenhao.github.io/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>nginx优化</title>
    <link href="https://talenhao.github.io/2019/08/28/nginx%E4%BC%98%E5%8C%96/"/>
    <id>https://talenhao.github.io/2019/08/28/nginx优化/</id>
    <published>2019-08-28T01:58:30.000Z</published>
    <updated>2019-08-28T01:58:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx性能优化"><a href="#nginx性能优化" class="headerlink" title="nginx性能优化"></a>nginx性能优化</h3><ol><li><p>考虑的方面</p><ol><li><p>当前系统的瓶颈</p><ol><li>服务类型结构特点</li><li>指标<ol><li>系统<ol><li>CPU</li><li>MEM</li><li>IO</li></ol></li><li>服务<ol><li>请求</li><li>日志分析统计</li></ol></li></ol></li><li>压力测试<ol><li>ab接口压力测试</li></ol></li></ol></li><li><p>了解业务类型</p><ol><li>业务接口类型</li><li>业务系统层次结构<ol><li>代理</li><li>中间件</li><li>服务层</li></ol></li></ol></li><li><p>性能与安全</p><ol><li><p>监听文件描述符的机制</p><ol><li><p>select</p><ol><li><p>每个socket(fd)对应一个connection</p></li><li><pre class="mermaid">               sequenceDiagramconnection->>select:requestloop 状态查询select->>socket:ready?alt not readysocket->>select: continueelse ready socket->>select: 从用户态复制FD到内核态,并遍历select->>connection: processendenduserspace->>kernelspace:copy_from_user复制fd_set到内核loop 注册回kernelspace->>kernelspace:注册回调函数__pollwaitkernelspace->>kernelspace:遍历fd_set,调用回调函数,放入队列中kernelspace->>kernelspace:消息完成后会激活队列相应的进程alt 将返回的事件消息作为fd的值maskkernelspace->>kernelspace: {key:fd mask:EVEN}else no mask kernelspace->>kernelspace: schudle_timeoutendkernelspace-->>userspace:复制fd_set回用户态end</pre></li></ol></li><li><p>poll</p><ol><li>类似select</li><li>使用链表,无最大连接数限制(由fd_set变成pollfd链表)</li></ol></li><li><p>epoll</p><ol><li><p>一个文件描述符FD</p></li><li><p>连接事件复制一次到内核事件表</p></li><li><p>无连接数限制</p></li><li><p>使用水平及边缘触发,非轮询,效率高,遍历就绪链表</p></li><li><p>使用mmap文件映射,内核消息传递减少开销.</p></li><li><pre class="mermaid">               sequenceDiagramevent->>handler:callback</pre></li><li><p>并发(在可接受的队列处理时间内的最大请求)-&gt;并行(多核并行[OS层]或单核分时复用[事件驱动])-&gt;异步</p><ol><li>异步框架(一个创建接口,一个主循环,一个回调)</li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>NGINX</p><ol><li>网络</li><li>操作系统<ol><li>文件句柄<ol><li>全局 /etc/security/limits.conf: hard/soft nofile</li><li>用户 /etc/security/limits.conf: hard/soft nofile</li><li>nginx进程: worker_rlimit_nofile: 35535</li></ol></li><li>CPU亲和(affinity)<ol><li>减少处理器迁移进程切换消耗cpu<ol><li>worker_cpu_affinity 0001 0010 0100 1000或auto或1010 0101</li></ol></li></ol></li></ol></li><li>nginx服务<ol><li>配置优化<ol><li>全局优化<ol><li>worker_processes number auto;worker进程的数量；通常应该等于小于当前主机的cpu的物理核心数； auto：当前主机物理CPU核心数；</li><li>worker_cpu_affinity auto;</li><li>wrker_priority number [-20, 20]</li><li>worker_rlimit_nofile number; worker进程所能够打开的文件数量上限；</li></ol></li><li>http<ol><li>charset utf-8;</li><li>access_log off;不必要的情况下可关闭日志.</li><li>sendfile on; 提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。</li><li>tcp_nopush on; TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 <code>tcp_nopush</code> 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。</li><li>tcp_nodeny on;TCP_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 <code>tcp_nodelay</code>。可以看到 TCP_NOPUSH 是要等数据包累积到一定大小才发送，TCP_NODELAY 是要尽快发送，二者相互矛盾。实际上，它们确实可以一起用，最终的效果是先填满包，再尽快发送。</li><li>keepalive-timeout 65;指定服务端为每个 TCP 连接最多可以保持多长时间Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒</li><li>gzip on;</li></ol></li></ol></li></ol></li><li>后端程序</li><li>数据库</li></ol></li></ol><h3 id="相同servername顺序"><a href="#相同servername顺序" class="headerlink" title="相同servername顺序"></a>相同servername顺序</h3><p>配置文件先读取原则 </p><h3 id="location正则匹配"><a href="#location正则匹配" class="headerlink" title="location正则匹配"></a>location正则匹配</h3><p><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/" target="_blank" rel="noopener">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优先级最高的两个匹配,匹配后不再搜索</span><br><span class="line">=</span><br><span class="line">^~</span><br><span class="line">正则匹配/无正则前辍匹配,匹配后还要向下搜索</span><br><span class="line">~</span><br><span class="line">~*</span><br><span class="line">/image</span><br></pre></td></tr></table></figure><h3 id="alias-root"><a href="#alias-root" class="headerlink" title="alias,root"></a>alias,root</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root+location</span><br><span class="line"><span class="built_in">alias</span>替换location</span><br></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>413-&gt;client_max_body_szie</p><p>502-&gt;后端服务无响应</p><p>504-&gt;后端服务执行超时</p><h3 id="nginx-rewrite"><a href="#nginx-rewrite" class="headerlink" title="nginx rewrite"></a>nginx rewrite</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳转型,浏览器对新地址重新进行请求</span></span><br><span class="line">redirect：302跳转到rewrtie后面的地址。</span><br><span class="line">permanent：301永久调整到rewrtie后面的地址，即当前地址已经永久迁移到新地址，一般是为了对搜索引擎友好。</span><br><span class="line"><span class="comment"># 代理型,服务器内部实现跳转,浏览器无需再次发起请求</span></span><br><span class="line">last：将rewrite后的地址重新在server标签执行。</span><br><span class="line">break：将rewrite后地址重新在当前的location标签执行。</span><br></pre></td></tr></table></figure><h3 id="nginx-try-files"><a href="#nginx-try-files" class="headerlink" title="nginx try_files"></a>nginx try_files</h3><p>动静分离,路径判断,重定向</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try_files指令：</span><br><span class="line">语法：try_files file ... uri 或 try_files file ... = code</span><br><span class="line">默认值：无</span><br><span class="line">作用域：server location</span><br></pre></td></tr></table></figure><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Nginx设置Referer来防止盗图</span><br><span class="line"><span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx信号："><a href="#nginx信号：" class="headerlink" title="nginx信号："></a>nginx信号：</h2><ol><li>TERM,INT快速关闭</li><li>HUP     平滑重启，加载配置(重启旧进程)</li><li>USR1    重新打开日志，切日志</li><li>USR2    平滑升级<ol><li>-&gt;  WINCH   从容关闭worker</li><li>-&gt;  QUIT    从容关闭master</li></ol></li></ol><p>config:<br>    worker_rlimit_nofile 51200;<br>    worker_connections   51200;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-server modules]# rpm -ql nginx</span><br><span class="line">/etc/logrotate.d/nginx</span><br><span class="line">/etc/nginx</span><br><span class="line">/etc/nginx/conf.d</span><br><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">/etc/nginx/fastcgi_params</span><br><span class="line">/etc/nginx/koi-utf</span><br><span class="line">/etc/nginx/koi-win</span><br><span class="line">/etc/nginx/mime.types</span><br><span class="line">/etc/nginx/modules</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/etc/nginx/scgi_params</span><br><span class="line">/etc/nginx/uwsgi_params</span><br><span class="line">/etc/nginx/win-utf</span><br><span class="line">/etc/sysconfig/nginx</span><br><span class="line">/etc/sysconfig/nginx-debug</span><br><span class="line">/usr/lib/systemd/system/nginx-debug.service</span><br><span class="line">/usr/lib/systemd/system/nginx.service</span><br><span class="line">/usr/lib64/nginx</span><br><span class="line">/usr/lib64/nginx/modules</span><br><span class="line">/usr/libexec/initscripts/legacy-actions/nginx</span><br><span class="line">/usr/libexec/initscripts/legacy-actions/nginx/check-reload</span><br><span class="line">/usr/libexec/initscripts/legacy-actions/nginx/upgrade</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line">/usr/sbin/nginx-debug</span><br><span class="line">/usr/share/doc/nginx-1.16.0</span><br><span class="line">/usr/share/doc/nginx-1.16.0/COPYRIGHT</span><br><span class="line">/usr/share/man/man8/nginx.8.gz</span><br><span class="line">/usr/share/nginx</span><br><span class="line">/usr/share/nginx/html</span><br><span class="line">/usr/share/nginx/html/50x.html</span><br><span class="line">/usr/share/nginx/html/index.html</span><br><span class="line">/var/cache/nginx</span><br><span class="line">/var/log/nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-server nginx]# nginx -V</span><br><span class="line">nginx version: nginx/1.16.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module--with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie'</span><br></pre></td></tr></table></figure><p>Nginx 监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><p>上面是一个实际网站的配置实例，其中灰色文字为配置说明。上述配置中，首先我们定义了一个 location ~ ^/NginxStatus/，这样通过 <a href="http://localhost/NginxStatus/" target="_blank" rel="noopener">http://localhost/NginxStatus/</a> 就可以监控到 Nginx 的运行信息，显示的内容如下：</p><p>Active connections: 70<br>server accepts handled requests<br> 14553819 14553819 19239266<br>Reading: 0 Writing: 3 Waiting: 67</p><p>NginxStatus 显示的内容意思如下：</p><pre><code>active connections – 当前 Nginx 正处理的活动连接数。server accepts handled requests -- 总共处理了 14553819 个连接 , 成功创建 14553819 次握手 ( 证明中间没有失败的 ), 总共处理了 19239266 个请求 ( 平均每次握手处理了 1.3 个数据请求 )。reading -- nginx 读取到客户端的 Header 信息数。writing -- nginx 返回给客户端的 Header 信息数。waiting -- 开启 keep-alive 的情况下，这个值等于 active - (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0  22720 2010244 169688 2594920    0    0     0     0 33433 16822  2 21 77  0  0</span><br><span class="line"> 2  0  22720 2010492 169688 2594952    0    0     0   412 34205 17057  3 21 76  0  0</span><br><span class="line"> 1  0  22720 2010864 169688 2593692    0    0     0     0 33576 16732  3 21 77  0  0</span><br><span class="line"> 1  0  22720 2009624 169696 2595632    0    0     0   404 33831 16805  3 20 77  0  0</span><br><span class="line"> 1  0  22720 2009500 169696 2594784    0    0     0     0 33843 16680  3 21 77  0  0</span><br><span class="line">[root@192-168-171-146 nginx]# vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0  22420 2207684  70400 2497512    0    0     7    56    2    1  1  5 93  0  0</span><br><span class="line"> 1  0  22420 2205872  70416 2500324    0    0     0   130 31450 15395  2  7 92  0  0</span><br><span class="line"> 1  0  22420 2203248  70432 2504292    0    0     0   110 31637 15802  2  7 91  0  0</span><br><span class="line"> 0  0  22420 2202296  70448 2506236    0    0     0   134 31459 15605  2  7 91  0  0</span><br><span class="line"> 0  0  22420 2202064  70460 2505480    0    0     0   447 31511 15458  2  7 91  1  0</span><br></pre></td></tr></table></figure><p>worker_cpu_affinity配置是写在/etc/nginx/nginx.conf里面的。</p><p>2核是 01，四核是0001，8核是00000001，有多少个核，就有几位数，1表示该内核开启，0表示该内核关闭。</p><ol start="5"><li>8核CPU，开户8个进程</li></ol><p>worker_processes     8;<br>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;<br>0001表示启用第一个CPU内核，0010表示启用第二个CPU内核，依此类推<br>worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。</p><p>优化TCP/IP连接，减少TIME-WAIT的命令<br>（一）TCP/IP连接的状态和对应的个数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | awk <span class="string">'/^tcp/ &#123;++s[$NF]&#125; END &#123;for(a in s) print a, s[a]&#125;'</span></span><br></pre></td></tr></table></figure><p>（二）提升服务器的负载能力：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 5</span><br></pre></td></tr></table></figure><p>参数说明：{<br>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；<br>net.ipv4.tcp_fin_timeout 修改系统默认的 TIMEOUT 时间。<br>}<br>（三）优化TCP/IP的可使用端口范围，进一步提升服务器的并发能力（针对tcp流量比较大的服务器）<br>net.ipv4.tcp_keepalive_time = 1200<br>net.ipv4.ip_local_port_range = 10000 65000<br>net.ipv4.tcp_max_syn_backlog = 8192<br>net.ipv4.tcp_max_tw_buckets = 5000</p><p>参数说明：{<br>net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</p><p>net.ipv4.ip_local_port_range = 10000 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。(注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！)<br>net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</p><p>net.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。<br>}<br>（四）修改 linux kernel 的 tcp time wait的时间（适用于大量短连接的情况）<br>在 $KERNEL/include/net/tcp.h里面，有下面的行：<br>    　　#define TCP_TIMEWAIT_LEN (60<em>HZ) /</em> how long to wait to destroy TIME-WAIT<br>    　　* state, about 60 seconds */<br>    　　而这个宏是真正控制 TCP TIME_WAIT 状态的超时时间的。如果我们希望减少 TIME_WAIT 状态的数目(从而节省一点点内核操作时间)，那么可以把这个数值设置低一些，根据我们的测试，设置为 10 秒比较合适，也就是把上面的修改为：</p><pre><code>　　#define TCP_TIMEWAIT_LEN (10*HZ) /* how long to wait to destroy TIME-WAIT　　* state, about 60 seconds */</code></pre><p>　　然后重新编译内核，重启系统即可发现短连接造成的TIME_WAIT状态大大减少：<br>　　netstat -ant | grep -i time_wait |wc -l<br>　　一般情况都可以至少减少2/3。也能相应提高系统应对短连接的速度</p><p>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_tw_recycle = 1<br>net.ipv4.tcp_fin_timeout = 5<br>参数说明：{<br>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；<br>net.ipv4.tcp_fin_timeout 修改系统默认的 TIMEOUT 时间。<br>}</p><p>Nginx做web服务器linux内核参数优化</p><p>Nginx提供web服务时Linux内核参数调整是必不可少的，其中在优化方面就需要我们格外的注意。在下面就是对Linux内核参数优化的详细介绍，希望大家有所收获。</p><p>关于Linux内核参数的优化：</p><p>net.ipv4.tcp_max_tw_buckets = 6000</p><p>timewait的数量，默认是180000。</p><p>net.ipv4.ip_local_port_range = 1024 65000</p><p>允许系统打开的端口范围。</p><p>net.ipv4.tcp_tw_recycle = 1</p><p>启用timewait快速回收。</p><p>net.ipv4.tcp_tw_reuse = 1</p><p>开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</p><p>net.ipv4.tcp_syncookies = 1</p><p>开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。</p><p>net.core.somaxconn = 262144</p><p>web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而Nginx内核参数定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</p><p>net.core.netdev_max_backlog = 262144</p><p>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</p><p>net.ipv4.tcp_max_orphans = 262144</p><p>系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</p><p>net.ipv4.tcp_max_syn_backlog = 262144</p><p>记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。</p><p>net.ipv4.tcp_timestamps = 0</p><p>时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</p><p>net.ipv4.tcp_synack_retries = 1</p><p>为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</p><p>net.ipv4.tcp_syn_retries = 1</p><p>在内核放弃建立连接之前发送SYN包的数量。</p><p>net.ipv4.tcp_fin_timeout = 1</p><p>如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</p><p>net.ipv4.tcp_keepalive_time = 30</p><p>当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@192-168-171-146 conf]<span class="comment"># ss -s</span></span><br><span class="line">Total: 12814 (kernel 12920)</span><br><span class="line">TCP:   16857 (estab 12572, closed 4096, orphaned 153, synrecv 0, timewait 4096/0), ports 1300</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line"></span><br><span class="line">- 12920     -         -</span><br><span class="line">  RAW       0         0         0</span><br><span class="line">  UDP       9         6         3</span><br><span class="line">  TCP       12761     12757     4</span><br><span class="line">  INET      12770     12763     7</span><br><span class="line">  FRAG      0         0         0</span><br><span class="line"></span><br><span class="line">[root@192-168-171-146 conf]<span class="comment"># ss -s</span></span><br><span class="line">Total: 44751 (kernel 44980)</span><br><span class="line">TCP:   48780 (estab 44533, closed 4096, orphaned 139, synrecv 0, timewait 4096/0), ports 2188</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line"></span><br><span class="line">- 44980     -         -</span><br><span class="line">  RAW       0         0         0</span><br><span class="line">  UDP       9         6         3</span><br><span class="line">  TCP       44684     44680     4</span><br><span class="line">  INET      44693     44686     7</span><br><span class="line">  FRAG      0         0         0</span><br></pre></td></tr></table></figure><h3 id="nginx-启用SSL"><a href="#nginx-启用SSL" class="headerlink" title="nginx  启用SSL"></a>nginx  启用SSL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--with-http_ssl_module  # This module requires the OpenSSL library</span><br></pre></td></tr></table></figure><p>在https页面中包含以http方式引入的图片、js等资源时，浏览器为了安全起见会阻止加载。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment">#侦听443端口，这个是ssl访问端口</span></span><br><span class="line">  <span class="attribute">listen</span>    <span class="number">443</span> ssl;</span><br><span class="line">  <span class="comment"># ssl on; 1.15版本这个参数已经废弃,使用listen ssl代替</span></span><br><span class="line">  <span class="attribute">ssl_protocols</span>       TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span>         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">  <span class="attribute">ssl_certificate</span>     /usr/local/nginx/conf/cert.pem;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /usr/local/nginx/conf/cert.key;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span>   shared:SSL:<span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;nginx性能优化&quot;&gt;&lt;a href=&quot;#nginx性能优化&quot; class=&quot;headerlink&quot; title=&quot;nginx性能优化&quot;&gt;&lt;/a&gt;nginx性能优化&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;考虑的方面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当前系统的瓶颈&lt;/p&gt;
      
    
    </summary>
    
      <category term="nginx" scheme="https://talenhao.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://talenhao.github.io/tags/nginx/"/>
    
  </entry>
  
</feed>
